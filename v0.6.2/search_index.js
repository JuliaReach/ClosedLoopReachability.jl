var documenterSearchIndex = {"docs":
[{"location":"models/TORA/#Translational-Oscillations-by-a-Rotational-Actuator-(TORA)","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The TORA benchmark models a cart attached to a wall with a spring. The cart is free to move on a friction-less surface and has a weight attached to an arm, which is free to rotate about an axis. This serves as the control input to stabilize the cart at the origin x = 0 [JFK96].","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"(Image: )","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"We consider two different scenarios. In the first scenario, we have a safety specification. In the other scenario, we have a reachability specification.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: UniformAdditivePostprocessing, NoSplitter, LinearMapPostprocessing\nusing Plots: plot, plot!, lens!, bbox","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The following option determines whether the verification settings should be used in the first scenario. The verification settings are chosen to show that the safety property is satisfied, which is expensive in this case. Concretely, we split the initial states into small chunks and run many analyses. Without the verification settings, the analysis is only run for a short time horizon.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"const verification = false;\nnothing #hide","category":"page"},{"location":"models/TORA/#Model","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Model","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The model is four-dimensional. The dynamics are given by the following equations:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"beginaligned\ndotx_1 = x_2 \ndotx_2 = -x_1 + 01 sin(x_3) \ndotx_3 = x_4  \ndotx_4 = u\nendaligned","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"vars_idx = Dict(:states => 1:4, :controls => 5)\n\n@taylorize function TORA!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, u = x\n\n    dx[1] = x₂\n    dx[2] = -x₁ + (0.1 * sin(x₃))\n    dx[3] = x₄\n    dx[4] = u\n    dx[5] = zero(u)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"We are given three neural-network controllers. All controllers have 3 hidden layers of 100 neurons each, 6 inputs (the state variables), and 1 output (u). The output of the neural networks N(x) needs to be normalized in order to obtain u.","category":"page"},{"location":"models/TORA/#Scenario-1","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The controller uses ReLU activations in all layers, including the output layer. The output normalization is u = N(x) - 10. The control period is 1 time unit.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"path = @current_path(\"TORA\", \"TORA_ReLU_controller.polar\")\ncontroller_ReLU = read_POLAR(path)\n\ncontrol_postprocessing1 = UniformAdditivePostprocessing(-10.0)\n\nperiod1 = 1.0;\nnothing #hide","category":"page"},{"location":"models/TORA/#Scenario-2","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"One controller has ReLU activations in all hidden layers and tanh activations in the output layer. The other controller has sigmoid activations in all layers, including the output layer. The output normalization is u = 11 N(x). The control period is 0.5 time units.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"path = @current_path(\"TORA\", \"TORA_ReLUtanh_controller.polar\")\ncontroller_relutanh = read_POLAR(path)\npath = @current_path(\"TORA\", \"TORA_sigmoid_controller.polar\")\ncontroller_sigmoid = read_POLAR(path)\n\ncontrol_postprocessing2 = LinearMapPostprocessing(11.0)\n\nperiod2 = 0.5;\nnothing #hide","category":"page"},{"location":"models/TORA/#Specification","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Specification","text":"","category":"section"},{"location":"models/TORA/#Scenario-1-2","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The uncertain initial condition is x_1  06 07 x_2  07 06 x_3  04 03 x_4  05 06.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"X₀1 = Hyperrectangle(low=[0.6, -0.7, -0.4, 0.5], high=[0.7, -0.6, -0.3, 0.6])\nU = ZeroSet(1);\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The initial-value problem is:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"ivp1 = @ivp(x' = TORA!(x), dim: 5, x(0) ∈ X₀1 × U);\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The safety specification is to stay within the box x  2 2^4 for a time horizon of 20 time units. A sufficient condition for guaranteed verification is to overapproximate the result with hyperrectangles.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"safe_states = cartesian_product(BallInf(zeros(4), 2.0), Universe(1))\n\npredicate1(sol, T) = overapproximate(sol, Hyperrectangle) ⊆ safe_states\n\nT1 = 20.0  # time horizon\nT1_warmup = 2 * period1  # shorter time horizon for warm-up run\nT1_reach = verification ? T1 : T1_warmup;  # shorter time horizon if not verifying\nnothing #hide","category":"page"},{"location":"models/TORA/#Scenario-2-2","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The uncertain initial condition is x_1  -077 -075 x_2  -045 -043 x_3  051 054 x_4  -03 -028.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"X₀2 = Hyperrectangle(low=[-0.77, -0.45, 0.51, -0.3], high=[-0.75, -0.43, 0.54, -0.28])\nU = ZeroSet(1);\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The initial-value problem is:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"ivp2 = @ivp(x' = TORA!(x), dim: 5, x(0) ∈ X₀2 × U);\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The specification is to reach the goal region x_1  -01 02 x_2  -09 -06 within 5 time units. A sufficient condition for guaranteed verification is to overapproximate the result at the end with a hyperrectangle.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"goal_states = cartesian_product(Hyperrectangle(low=[-0.1, -0.9], high=[0.2, -0.6]),\n                                Universe(3))\n\npredicate_set2(R) = overapproximate(R, Hyperrectangle) ⊆ goal_states\n\npredicate2(sol, T) = all(predicate_set2(F[end]) for F in sol if T ∈ tspan(F))\n\nT2 = 5.0  # time horizon\nT2_warmup = 2 * period2;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/TORA/#Analysis","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Analysis","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"algorithm_plant_1 = TMJets(abstol=3e-2, orderT=3, orderQ=1);\nalgorithm_plant_2 = TMJets(abstol=2e-2, orderT=3, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"To propagate sets through the neural network, we use the DeepZ algorithm. For verification, we also use an additional splitting strategy to increase the precision in scenario 1.","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The verification benchmark is given below:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"function benchmark(prob; T, splitter, algorithm_plant, predicate,\n                   silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol, T)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\n\nfunction run(; scenario1::Bool, ReLUtanh_activations)\n    if scenario1\n        println(\"# Running analysis of scenario 1 with ReLU activations\")\n        prob = ControlledPlant(ivp1, controller_ReLU, vars_idx, period1;\n                               postprocessing=control_postprocessing1)\n        splitter = verification ? BoxSplitter([4, 4, 3, 5]) : NoSplitter()\n        algorithm_plant = algorithm_plant_1\n        predicate = predicate1\n        T = T1_reach\n        T_warmup = T1_warmup\n    else\n        splitter = NoSplitter()\n        algorithm_plant = algorithm_plant_2\n        predicate = predicate2\n        T = T2\n        T_warmup = T2_warmup\n        if ReLUtanh_activations\n            println(\"# Running analysis of scenario 2 with ReLUtanh activations\")\n            prob = ControlledPlant(ivp2, controller_relutanh, vars_idx, period2;\n                                   postprocessing=control_postprocessing2)\n        else\n            println(\"# Running analysis of scenario 2 with sigmoid activations\")\n            prob = ControlledPlant(ivp2, controller_sigmoid, vars_idx, period2;\n                                   postprocessing=control_postprocessing2)\n        end\n    end\n\n    # Run the verification benchmark:\n    benchmark(prob; T=T_warmup, splitter=splitter,\n        algorithm_plant=algorithm_plant, predicate=predicate, silent=true)  # warm-up\n    res = @timed benchmark(prob; T=T, splitter=splitter,\n        algorithm_plant=algorithm_plant, predicate=predicate)  # benchmark\n    sol, result = res.value\n    @assert (result == \"verified\") \"verification failed\"\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    if scenario1\n        res = @timed simulate(prob; T=T, trajectories=10, include_vertices=true)\n    else\n        res = @timed simulate(prob; T=T, trajectories=1, include_vertices=true)\n    end\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim\nend;\nnothing #hide","category":"page"},{"location":"models/TORA/#Scenario-1-3","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Run the verification benchmark:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"sol_r, sim_r = run(scenario1=true, ReLUtanh_activations=nothing);\nnothing #hide","category":"page"},{"location":"models/TORA/#Scenario-2-3","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Run the verification benchmark for the controller with sigmoid activations:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"sol_sig, sim_sig = run(scenario1=false, ReLUtanh_activations=false);\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Run the verification benchmark for the controller with ReLU/tanh activations:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"sol_rt, sim_rt = run(scenario1=false, ReLUtanh_activations=true);\nnothing #hide","category":"page"},{"location":"models/TORA/#Results","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Results","text":"","category":"section"},{"location":"models/TORA/#Scenario-1-4","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Preprocess the results:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"solz = overapproximate(sol_r, Zonotope);\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Script to plot the results:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"function plot_helper1(vars)\n    fig = plot()\n    plot!(fig, project(safe_states, vars); color=:lightgreen, lab=\"safe\")\n    plot!(fig, solz; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀1, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim_r; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Plot the results:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"vars = (1, 2)\nfig = plot_helper1(vars)\nplot!(fig; xlab=\"x₁\", ylab=\"x₂\")\n# Plots.savefig(fig, \"TORA-ReLU-x1-x2.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"vars = (3, 4)\nfig = plot_helper1(vars)\nplot!(fig; xlab=\"x₃\", ylab=\"x₄\")\n# Plots.savefig(fig, \"TORA-ReLU-x3-x4.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/TORA/#Scenario-2-4","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"","category":"section"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Script to plot the results:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"function plot_helper2(sol, sim)\n    vars = (1, 2)\n    fig = plot()\n    plot!(fig, project(goal_states, vars); color=:cyan, lab=\"goal\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀2, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    plot!(fig; xlab=\"x₁\", ylab=\"x₂\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"Plot the results:","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"fig = plot_helper2(sol_sig, sim_sig)\nlens!(fig, [-0.785, -0.735], [-0.47, -0.41]; inset=(1, bbox(0.2, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[-0.77, -0.75], yticks=[-0.45, -0.43], subplot=3)\nlens!(fig, [0.09, 0.22], [-0.9, -0.8]; inset=(1, bbox(0.6, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[0.1, 0.2], yticks=[-0.9, -0.8], subplot=3)\n# Plots.savefig(fig, \"TORA-sigmoid.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/TORA/","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"fig = plot_helper2(sol_rt, sim_rt)\nlens!(fig, [-0.785, -0.735], [-0.47, -0.41]; inset=(1, bbox(0.2, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[-0.77, -0.75], yticks=[-0.45, -0.43], subplot=3)\nlens!(fig, [0.0, 0.25], [-0.85, -0.7]; inset=(1, bbox(0.6, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[0, 0.2], yticks=[-0.8, -0.7], subplot=3)\n# Plots.savefig(fig, \"TORA-ReLUtanh.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/SpacecraftDocking/#Spacecraft-Docking","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"","category":"section"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"The Spacecraft Docking benchmark is a model of a docking spacecraft in 2D.","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"(Image: )","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing Plots: plot, plot!","category":"page"},{"location":"models/SpacecraftDocking/#Model","page":"Spacecraft Docking","title":"Model","text":"","category":"section"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"There are 4 state variables (s_x s_y dots_x dots_y), where (s_x s_y) is the position and (dots_x dots_y) is the velocity of the spacecraft [RCM+22].","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"vars_idx = Dict(:states => 1:4, :controls => 5:6)\n\nconst m = 12.0\nconst n = 0.001027\nconst three_n² = 3 * n^2\nconst two_n = 2 * n\n\n@taylorize function SpacecraftDocking!(dx, x, p, t)\n    s_x, s_y, s_x′, s_y′, F_x, F_y = x\n\n    dx[1] = s_x′\n    dx[2] = s_y′\n    dx[3] = three_n² * s_x + two_n * s_y′ + F_x / m\n    dx[4] = -two_n * s_x′ + F_y / m\n    dx[5] = zero(F_x)\n    dx[6] = zero(F_y)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"We are given a neural-network controller with 4 hidden layers of 4, 256, 256, and 4 neurons, respectively, identity activations in the first and fourth hidden layer (which represent a pre- and postprocessing via linear maps), and tanh activations everywhere else. The controller has 4 inputs (the state variables) and 2 outputs (F_x F_y).","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"path = @current_path(\"SpacecraftDocking\", \"SpacecraftDocking_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"The control period is 1 time unit.","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"period = 1.0;\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/#Specification","page":"Spacecraft Docking","title":"Specification","text":"","category":"section"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"We consider a smaller uncertain initial condition than originally proposed:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"X₀ = Hyperrectangle(low=[70, 70, -0.14, -0.14], high=[106, 106, 0.14, 0.14])\nU₀ = ZeroSet(2);\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"The control problem is:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"ivp = @ivp(x' = SpacecraftDocking!(x), dim: 6, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"The safety specification is given as follows:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"dots_x^2 + dots_y^2  02 + 2 n s_x^2 + s_y^2","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"A sufficient condition for guaranteed verification is to overapproximate the result via interval arithmetic.","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"function predicate_point(v::Union{AbstractVector,IntervalBox})\n    x, y, x′, y′, F_x, F_y = v\n    lhs = sqrt(x′^2 + y′^2)\n    rhs = 0.2 + two_n * sqrt(x^2 + y^2)\n    return sup(lhs) <= inf(rhs)\nend\n\nfunction predicate_set(R)\n    return predicate_point(convert(IntervalBox, box_approximation(R)))\nend\n\npredicate(sol) = all(predicate_set(R) for F in sol for R in F)\n\nT = 40.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/#Analysis","page":"Spacecraft Docking","title":"Analysis","text":"","category":"section"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"algorithm_plant = TMJets(abstol=5e-1, orderT=3, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"To propagate sets through the neural network, we use the DeepZ algorithm:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"The verification benchmark is given below:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"function benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"Run the verification benchmark and compute some simulations:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"benchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=1, include_vertices=true)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/#Results","page":"Spacecraft Docking","title":"Results","text":"","category":"section"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"Script to plot the results:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"function plot_helper(vars)\n    fig = plot()\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    if vars[1] == 0\n        initial_states_projected = cartesian_product(Singleton([0.0]), project(X₀, [vars[2]]))\n        plot!(fig, initial_states_projected; c=:cornflowerblue, alpha=1, lab=\"X₀\",\n              m=:none, lw=3)\n    else\n        plot!(fig, project(X₀, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    end\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"Plot the results:","category":"page"},{"location":"models/SpacecraftDocking/","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"vars = (0, 1)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"t\", ylab=\"x₁\")\n# Plots.savefig(fig, \"SpacecraftDocking.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Airplane/#Airplane","page":"Airplane","title":"Airplane","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The Airplane benchmark is a simple model of a flying airplane.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing Plots: plot, plot!, xlims!, ylims!","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The following option determines whether the falsification settings should be used. The falsification settings are sufficient to show that the safety property is violated. Concretely, we start from an initial point and use a smaller time horizon.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"const falsification = true;\nnothing #hide","category":"page"},{"location":"models/Airplane/#Model","page":"Airplane","title":"Model","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"There are 12 state variables:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"(s_x s_y s_z v_x v_y v_z ϕ θ ψ r p q)","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"where (s_x s_y s_z) is the position of the center of gravity and (v_x v_y v_z) are the components of velocity, both in (x y z) directions, (p q r) are the body rotation rates, and (ϕ θ ψ) are the Euler angles. The coordinates are visualized below.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"(Image: )","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The equations of motion are reduced to:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"beginaligned\ndotv_x =  g sin(θ) + dfracF_xm - q v_z + r v_y \ndotv_y = g cos(θ) sin(ϕ) + dfracF_ym - r v_x + p v_z \ndotv_z = g cos(θ) cos(ϕ) + dfracF_zm - p v_y + q v_x \nI_x dotp + I_xz dotr = M_x - (I_z - I_y) q r - I_xz p q \nI_y dotq = M_y - I_xz(r^2 - p^2) - (I_x - I_z) p r \nI_xz dotp + I_z dotr = M_z - (I_y - I_x) q p - I_xz r q\nendaligned","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"where m denotes the mass of the airplane, I_x, I_y, I_z, and I_xz are the moments of inertia with respect to the indicated axis, and the control parameters consist of the three force components F_x, F_y, F_z and the three moment components M_x, M_y, M_z. For simplicity, we assume that the aerodynamic forces are absorbed in the F's. Beside the above six equations, we have six additional kinematic equations:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"beginpmatrix\ndots_x  dots_y  dots_z\nendpmatrix\n=\nbeginpmatrix\ncos(ψ)  -sin(ψ)  0 \nsin(ψ)  cos(ψ)  0 \n0  0  1\nendpmatrix\nbeginpmatrix\ncos(θ)  0  sin(θ) \n0  1  0 \n-sin(θ)  0  cos(θ)\nendpmatrix\nbeginpmatrix\n1  0  0 \n0  cos(ϕ)  -sin(ϕ) \n0  sin(ϕ)  cos(ϕ)\nendpmatrix\nbeginpmatrix\nv_x  v_y  v_z\nendpmatrix","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"and","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"beginpmatrix\ndotϕ  dotθ  dotψ\nendpmatrix\n=\nbeginpmatrix\n1  tan(θ) sin(ϕ)  tan(θ) cos(ϕ) \n0  cos(ϕ)  -sin(ϕ) \n0  sec(θ) sin(ϕ)  sec(θ) cos(ϕ)\nendpmatrix\nbeginpmatrix\np  q  r\nendpmatrix","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"For simplicity of the control design, the parameters have been chosen to have some nominal dimensionless values: m = 1, I_x = I_y = I_z = 1, I_xz = 0 and g = 1.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"vars_idx = Dict(:states => 1:12, :controls => 13:18)\n\nconst m = 1.0\nconst g = 1.0\n\nTψ(ψ) = [ cos(ψ)  -sin(ψ)  zero(ψ);\n          sin(ψ)   cos(ψ)  zero(ψ);\n         zero(ψ)  zero(ψ)   one(ψ)]\n\nTθ(θ) = [ cos(θ)  zero(θ)   sin(θ);\n         zero(θ)   one(θ)  zero(θ);\n         -sin(θ)  zero(θ)   cos(θ)]\n\nTϕ(ϕ) = [one(ϕ)  zero(ϕ)  zero(ϕ);\n         zero(ϕ)  cos(ϕ)  -sin(ϕ);\n         zero(ϕ)  sin(ϕ)   cos(ϕ)]\n\nRϕθ(ϕ, θ) = [ one(ϕ)  tan(θ) * sin(ϕ)  tan(θ) * cos(ϕ);\n             zero(ϕ)           cos(θ)          -sin(ϕ);\n             zero(ϕ)  sec(θ) * sin(ϕ)  sec(θ) * cos(ϕ)]\n\n@taylorize function Airplane!(dx, x, params, t)\n    s_x, s_y, s_z, v_x, v_y, v_z, ϕ, θ, ψ, r, p, q, Fx, Fy, Fz, Mx, My, Mz = x\n\n    T_ψ = Tψ(ψ)\n    T_θ = Tθ(θ)\n    T_ϕ = Tϕ(ϕ)\n    mat_1 = T_ψ * T_θ * T_ϕ\n    xyz = mat_1 * vcat(v_x, v_y, v_z)\n\n    mat_2 = Rϕθ(ϕ, θ)\n    ϕθψ = mat_2 * vcat(p, q, r)\n\n    dx[1] = xyz[1]\n    dx[2] = xyz[2]\n    dx[3] = xyz[3]\n    dx[4] = -g * sin(θ) + Fx / m - q * v_z + r * v_y\n    dx[5] = g * cos(θ) * sin(ϕ) + Fy / m - r * v_x + p * v_z\n    dx[6] = g * cos(θ) * cos(ϕ) + Fz / m - p * v_y + q * v_x\n    dx[7] = ϕθψ[1]\n    dx[8] = ϕθψ[2]\n    dx[9] = ϕθψ[3]\n    dx[10] = Mz  # simplified term\n    dx[11] = Mx  # simplified term\n    dx[12] = My  # simplified term\n    dx[13] = zero(Fx)\n    dx[14] = zero(Fy)\n    dx[15] = zero(Fz)\n    dx[16] = zero(Mx)\n    dx[17] = zero(My)\n    dx[18] = zero(Mz)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"We are given a neural-network controller with 3 hidden layers of 100, 100, and 20 neurons, respectively, and ReLU activations. The controller has 12 inputs (the state variables) and 6 outputs (F_x F_y F_z M_x M_y M_z).","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"path = @current_path(\"Airplane\", \"Airplane_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The control period is 0.1 time units.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"period = 0.1;\nnothing #hide","category":"page"},{"location":"models/Airplane/#Specification","page":"Airplane","title":"Specification","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The uncertain initial condition is:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"X₀ = Hyperrectangle(low=[0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                    high=[0.0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0])\nif falsification\n    # Choose a single point in the initial states (here: the top-most one):\n    X₀ = Singleton(high(X₀))\nend\nU₀ = ZeroSet(6);\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The control problem is:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"ivp = @ivp(x' = Airplane!(x), dim: 18, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The safety specification is that (x_2 x_7 x_8 x_9)  1 1 1 1 for 20 control periods. A sufficient condition for guaranteed violation is to overapproximate the result with hyperrectangles.","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"safe_states = concretize(CartesianProductArray([\n    Universe(1), Interval(-1.0, 1.0), Universe(4),\n    BallInf(zeros(3), 1.0), Universe(9)]))\n\npredicate_set(R) = isdisjoint(overapproximate(R, Hyperrectangle), safe_states)\n\nfunction predicate(sol; silent::Bool=false)\n    for F in sol, R in F\n        if predicate_set(R)\n            silent || println(\"  Violation for time range $(tspan(R)).\")\n            return true\n        end\n    end\n    return false\nend\n\nif falsification\n    k = 7  # falsification can run for a shorter time horizon\nelse\n    k = 20\nend\nT = k * period\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/Airplane/#Analysis","page":"Airplane","title":"Analysis","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"algorithm_plant = TMJets(abstol=2e-2, orderT=3, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"To propagate sets through the neural network, we use the DeepZ algorithm:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"The falsification benchmark is given below:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"function benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol; silent=silent)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is violated.\")\n        result = \"falsified\"\n    else\n        silent || println(\"  The property may be satisfied.\")\n        result = \"not falsified\"\n    end\n\n    return sol, result\nend;\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"Run the falsification benchmark and compute some simulations:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"benchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"falsified\") \"falsification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=falsification ? 1 : 10,\n                      include_vertices=!falsification)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Airplane/#Results","page":"Airplane","title":"Results","text":"","category":"section"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"Script to plot the results:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"function plot_helper(vars)\n    fig = plot()\n    plot!(fig, project(safe_states, vars); color=:lightgreen, lab=\"safe\")\n    plot!(fig, project(initial_state(prob), vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    lab_sim = falsification ? \"simulation\" : \"\"\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"Plot the results:","category":"page"},{"location":"models/Airplane/","page":"Airplane","title":"Airplane","text":"vars = (2, 7)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"s_y\", ylab=\"ϕ\", leg=:bottomleft)\nif falsification\n    xlims!(-0.01, 1.15)\n    ylims!(0.5, 1.01)\nelse\n    xlims!(-0.55, 0.55)\n    ylims!(-1.05, 1.05)\nend\n# Plots.savefig(fig, \"Airplane.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/InvertedTwoLinkPendulum/#Inverted-Two-Link-Pendulum","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"","category":"section"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The Inverted Two-Link Pendulum benchmark is a classical inverted pendulum with two links. We consider two different scenarios, which we respectively refer to as the less robust and the more robust scenario.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: Specification, NoSplitter\nusing Plots: plot, plot!, xlims!, ylims!","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The following option determines whether the verification settings should be used in the less robust scenario. The verification settings are chosen to show that the safety property is satisfied, which is expensive in this case. Concretely, we split the initial states into small chunks and run many analyses. Without the verification settings, the analysis is only run for a short time horizon.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"const verification = false;\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The following option determines whether the falsification settings should be used in the more robust scenario. The falsification settings are sufficient to show that the safety property is violated. Concretely, we start from an initial point and use a smaller time horizon.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"const falsification = true;\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/#Model","page":"Inverted Two-Link Pendulum","title":"Model","text":"","category":"section"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The double-link inverted pendulum consists of equal point masses m at the end of connected mass-less links of length L. Both links are actuated with torques T_1 and T_2. We assume viscous friction with coefficient c.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The governing equations of motion can be obtained as:","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"beginaligned\n2 ddot θ_1 + ddot θ_2 cos(θ_2 - θ_1) - ddot θ_2^2 sin(θ_2 - θ_1) -\n    2 dfracgL sin(θ_1) + dfraccm L^2 dotθ_1 = dfrac1m L^2 T_1 \nddot θ_1 cos(θ_2 - θ_1) + ddot θ_2 + ddot θ_1^2 sin(θ_2 - θ_1) -\n    dfracgL sin(θ_2) + dfraccm L^2 dotθ_2 = dfrac1m L^2 T_2\nendaligned","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"where θ_1 and θ_2 are the angles that the links make with the upward vertical axis, dotθ_1 and dotθ_2 are the angular velocities, and g is the gravitational acceleration. The state vector is (θ_1 θ_2 dotθ_1 dotθ_2). See the picture below for a visualization.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"(Image: )","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The dynamics are given as first-order differential equations below.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"vars_idx = Dict(:states => 1:4, :controls => 5:6)\n\nconst m = 0.5\nconst L = 0.5\nconst c = 0.0\nconst g = 1.0\nconst gL = g / L\nconst mL = 1 / (m * L^2)\n\n@taylorize function InvertedTwoLinkPendulum!(dx, x, p, t)\n    θ₁, θ₂, θ₁′, θ₂′, T₁, T₂ = x\n\n    Δ12 = θ₁ - θ₂\n    cos12 = cos(Δ12)\n    x3sin12 = θ₁′^2 * sin(Δ12)\n    x4sin12 = θ₂′^2 * sin(Δ12) / 2\n    gLsin1 = gL * sin(θ₁)\n    gLsin2 = gL * sin(θ₂)\n    T1_frac = (T₁ - c * θ₁′) * (0.5 * mL)\n    T2_frac = (T₂ - c * θ₂′) * mL\n    bignum = x3sin12 - cos12 * (gLsin1 - x4sin12 + T1_frac) + gLsin2 + T2_frac\n    denom = cos12^2 / 2 - 1\n\n    dx[1] = θ₁′\n    dx[2] = θ₂′\n    dx[3] = cos12 * bignum / (2 * denom) - x4sin12 + gLsin1 + T1_frac\n    dx[4] = -bignum / denom\n    dx[5] = zero(T₁)\n    dx[6] = zero(T₂)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"We are given two neural-network controllers with 2 hidden layers of 25 neurons each and ReLU activations. Both controllers have 4 inputs (the state variables) and 2 output (T₁ and T₂).","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"path = @current_path(\"InvertedTwoLinkPendulum\",\n                     \"InvertedTwoLinkPendulum_controller_less_robust.polar\")\ncontroller_lr = read_POLAR(path)\n\npath = @current_path(\"InvertedTwoLinkPendulum\",\n                     \"InvertedTwoLinkPendulum_controller_more_robust.polar\")\ncontroller_mr = read_POLAR(path);\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The controllers have different control periods: 0.05 (less robust) resp. 0.02 (more robust) time units.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"period_lr = 0.05\nperiod_mr = 0.02;\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/#Specification","page":"Inverted Two-Link Pendulum","title":"Specification","text":"","category":"section"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The uncertain initial condition is (θ_1 θ_2 dotθ_1 dotθ_2)  1 13^4.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The safety specification is that, for all times t for 20 control periods, we have (θ_1 θ_2 dotθ_1 dotθ_2)  -1 17^4 (less robust scenario) respectively (θ_1 θ_2 dotθ_1 dotθ_2)  -05 15^4 (more robust scenario). A sufficient condition for guaranteed violation is to overapproximate the result with hyperrectangles.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The following script creates a different problem instance for the less robust and the more robust scenario, respectively.","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"function InvertedTwoLinkPendulum_spec(less_robust_scenario::Bool)\n    controller = less_robust_scenario ? controller_lr : controller_mr\n\n    X₀ = BallInf(fill(1.15, 4), 0.15)\n    if falsification && !less_robust_scenario\n        # Choose a single point in the initial states (here: the top-most one):\n        X₀ = Singleton(high(X₀))\n    end\n    U₀ = ZeroSet(2)\n\n    period = less_robust_scenario ? period_lr : period_mr\n\n    # The control problem is:\n    ivp = @ivp(x' = InvertedTwoLinkPendulum!(x), dim: 6, x(0) ∈ X₀ × U₀)\n    prob = ControlledPlant(ivp, controller, vars_idx, period)\n\n    # Safety specification:\n    if less_robust_scenario\n        box = BallInf(fill(0.15, 4), 1.85)\n    else\n        box = BallInf(fill(0.0, 4), 1.5)\n    end\n    safe_states = cartesian_product(box, Universe(2))\n\n    predicate_set_safe(R) = overapproximate(R, Hyperrectangle) ⊆ safe_states\n    predicate_set_unsafe(R) = isdisjoint(overapproximate(R, Hyperrectangle), safe_states)\n\n    function predicate_safe(sol; silent::Bool=false)\n        for F in sol, R in F\n            if !predicate_set_safe(R)\n                silent || println(\"  Potential violation for time range $(tspan(R)).\")\n                return false\n            end\n        end\n        return true\n    end\n\n    function predicate_unsafe(sol)\n        for F in sol, R in F\n            if predicate_set_unsafe(R)\n                return true\n            end\n        end\n        return false\n    end\n\n    if less_robust_scenario\n        predicate = predicate_safe\n    else\n        predicate = predicate_unsafe\n    end\n\n    if !verification && less_robust_scenario\n        # Run for a shorter time horizon if verification is deactivated:\n        k = 2\n    elseif falsification && !less_robust_scenario\n        # Falsification can run for a shorter time horizon:\n        k = 18\n    else\n        k = 20\n    end\n    T = k * period  # time horizon\n\n    spec = Specification(T, predicate, safe_states)\n\n    return prob, spec\nend;\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/#Analysis","page":"Inverted Two-Link Pendulum","title":"Analysis","text":"","category":"section"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm. We also use an additional splitting strategy to increase the precision. These algorithms are defined later for each scenario. To propagate sets through the neural network, we use the DeepZ algorithm:","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The verification/falsification benchmark (depending on the scenario) is given below:","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"function benchmark(prob, spec; T, algorithm_plant, splitter, less_robust_scenario, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    if less_robust_scenario\n        res = @timed spec.predicate(sol; silent=silent)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is verified.\")\n            result = \"verified\"\n        else\n            silent || println(\"  The property may be violated.\")\n            result = \"not verified\"\n        end\n    else\n        res = @timed spec.predicate(sol)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is violated.\")\n            result = \"falsified\"\n        else\n            silent || println(\"  The property may be satisfied.\")\n            result = \"not falsified\"\n        end\n    end\n\n    return sol, result\nend\n\nfunction run(; less_robust_scenario::Bool)\n    if less_robust_scenario\n        println(\"# Running analysis with less robust scenario\")\n        algorithm_plant = TMJets(abstol=1e-9, orderT=5, orderQ=1)\n        splitter = !verification ? BoxSplitter([[1.15], [1.15], Float64[], [1.2]]) :\n            BoxSplitter([[1.15], [1.15], [1.12, 1.25], [1.05, 1.11, 1.165, 1.21, 1.257]])\n        T_warmup = 2 * period_lr  # shorter time horizon for warm-up run\n    else\n        println(\"# Running analysis with more robust scenario\")\n        algorithm_plant = TMJets(abstol=1e-2, orderT=3, orderQ=1)\n        splitter = NoSplitter()\n        T_warmup = 2 * period_mr  # shorter time horizon for warm-up run\n    end\n    prob, spec = InvertedTwoLinkPendulum_spec(less_robust_scenario)\n\n    # Run the verification/falsification benchmark:\n    benchmark(prob, spec; T=T_warmup, algorithm_plant=algorithm_plant, splitter=splitter,\n              less_robust_scenario=less_robust_scenario, silent=true)  # warm-up\n    res = @timed benchmark(prob, spec; T=spec.T, algorithm_plant=algorithm_plant,  # benchmark\n                           splitter=splitter, less_robust_scenario=less_robust_scenario)\n    sol, result = res.value\n    if verification && less_robust_scenario\n        @assert (result == \"verified\") \"verification failed\"\n    elseif !less_robust_scenario\n        @assert (result == \"falsified\") \"falsification failed\"\n    end\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    simulations = less_robust_scenario || !falsification\n    trajectories = simulations ? 10 : 1\n    res = @timed simulate(prob; T=spec.T, trajectories=trajectories,\n                          include_vertices=simulations)\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim, prob, spec\nend;\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"Run the analysis script for the less robust scenario:","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"sol_lr, sim_lr, prob_lr, spec_lr = run(less_robust_scenario=true);\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"Run the analysis script for the more robust scenario:","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"sol_mr, sim_mr, prob_mr, spec_mr = run(less_robust_scenario=false);\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/#Results","page":"Inverted Two-Link Pendulum","title":"Results","text":"","category":"section"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"Script to plot the results:","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"function plot_helper(vars, sol, sim, prob, spec; lab_sim=\"\")\n    safe_states = spec.ext\n    fig = plot()\n    plot!(fig, project(safe_states, vars); color=:lightgreen, lab=\"safe\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(initial_state(prob), vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"Plot the results:","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"vars = (1, 2)\nfig = plot_helper(vars, sol_lr, sim_lr, prob_lr, spec_lr)\nplot!(fig; xlab=\"θ₁\", ylab=\"θ₂\")\n# Command to save the plot to a file:\n# Plots.savefig(fig, \"InvertedTwoLinkPendulum-less-robust-x1-x2.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"vars = (3, 4)\nfig = plot_helper(vars, sol_lr, sim_lr, prob_lr, spec_lr)\nplot!(fig; xlab=\"θ₁'\", ylab=\"θ₂'\")\n# Command to save the plot to a file:\n# Plots.savefig(fig, \"InvertedTwoLinkPendulum-less-robust-x3-x4.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/InvertedTwoLinkPendulum/","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"vars = (3, 4)\nlab_sim = falsification ? \"simulation\" : \"\"\nfig = plot_helper(vars, sol_mr, sim_mr, prob_mr, spec_mr; lab_sim=lab_sim)\nplot!(fig; xlab=\"θ₁'\", ylab=\"θ₂'\")\n# Command to save the plot to a file:\n# Plots.savefig(fig, \"InvertedTwoLinkPendulum-more-robust.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/VerticalCAS/#Vertical-Collision-Avoidance-System-(VerticalCAS)","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"","category":"section"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"The VerticalCAS benchmark considers a collision avoidance system (CAS), required for commercial aircraft, which gives vertical climbrate advisories to pilots [JK19, ABKL20].","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"using ClosedLoopReachability, LinearAlgebra\nimport Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: FeedforwardNetwork\nusing Plots: plot, plot!","category":"page"},{"location":"models/VerticalCAS/#Model","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Model","text":"","category":"section"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"This model is a closed-loop variant of the aircraft collision avoidance system ACAS X. The considered scenario involves two aircraft, the ownship and the intruder, where the ownship is equipped with a collision avoidance system referred to as VerticalCAS. VerticalCAS issues vertical climbrate advisories to the ownship pilot every second to avoid a near mid-air collision (NMAC), which is the region where the aircraft are separated by less than 100 ft vertically and 500 ft horizontally. The ownship is assumed to have a constant horizontal speed, and the intruder is assumed to follow a constant horizontal trajectory toward the ownship. The figure below illustrates the scenario, where the ownship is shown in black and the intruder is shown in red.","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"(Image: )","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"The current geometry of the system is described by the intruder altitude relative to the ownship h (in ft), the ownship vertical climbrate doth_0 (in ft/min), and the time τ (in seconds) until the ownship and intruder are no longer horizontally separated. We can assume that the intruder is static and the horizontal separation τ decreases by 1 each second.","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"In addition to the parameters describing the geometry of the encounter, the dynamics also depend on the advisory textitadv issued to the ownship at the previous time step. The following data structure stores all this information:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"struct State{T}\n    state::T  # state for (h, hdot0) variables\n    τ::Float64\n    adv::Symbol\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"There are 9 advisories, each of which instructs the pilot to accelerate until the vertical climbrate of the ownship complies with the advisory:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"COC: Clear of Conflict\nDNC: Do Not Climb\nDND: Do Not Descend\nDES1500: Descend at least 1500 ft/min\nCL1500: Climb at least 1500 ft/min\nSDES1500: Strengthen Descent to at least 1500 ft/min\nSCL1500: Strengthen Climb to at least 1500 ft/min\nSDES2500: Strengthen Descent to at least 2500 ft/min\nSCL2500: Strengthen Climb to at least 2500 ft/min","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"const index2advisory = [:COC, :DNC, :DND, :DES1500, :CL1500,\n                        :SDES1500, :SCL1500, :SDES2500, :SCL2500];\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"We create a dictionary that maps each advisory to a set corresponding to the respective constraint on the climbrate:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"const advisory2set = Dict{Symbol,LazySet}()\nadvisory2set[:COC] = EmptySet(1)\nadvisory2set[:DNC] = HalfSpace([1.0], 0.0)\nadvisory2set[:DND] = HalfSpace([-1.0], 0.0)\nadvisory2set[:DES1500] = HalfSpace([1.0], -1500.0)\nadvisory2set[:CL1500] = HalfSpace([-1.0], -1500.0)\nadvisory2set[:SDES1500] = HalfSpace([1.0], -1500.0)\nadvisory2set[:SCL1500] = HalfSpace([-1.0], -1500.0)\nadvisory2set[:SDES2500] = HalfSpace([1.0], -2500.0)\nadvisory2set[:SCL2500] = HalfSpace([-1.0], -2500.0);\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"VerticalCAS is implemented as nine neural networks N_i, one for each (previous) advisory. All neural networks have the same structure: five hidden layers of 20 neurons each and ReLU activations, three inputs (h doth_0 τ), and nine outputs representing the score of each possible advisory.","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"We create a dictionary that maps each advisory to the respective controller:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"const advisory2controller = Dict{Symbol,FeedforwardNetwork}()\n\npath_prefix = @current_path(\"VerticalCAS\", \"\")\nfor i in 1:9\n    path = joinpath(path_prefix, \"VerticalCAS_controller_$(i).polar\")\n    adv = index2advisory[i]\n    advisory2controller[adv] = read_POLAR(path)\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Before passing the input to the neural networks, it has to be normalized by shifting and scaling in each dimension:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"const normalization_additive = -[0.0, 0, 20]\nconst normalization_multiplicative = 1.0 ./ [16000.0, 5000, 40]\nconst normalization_multiplicative_X = diagm(normalization_multiplicative)\n\nfunction normalize(x::AbstractVector)\n    y = x .+ normalization_additive\n    z = normalization_multiplicative .* y\n    return z\nend\n\nfunction normalize(X::LazySet)\n    Y = translate(X, normalization_additive)\n    Z = linear_map(normalization_multiplicative_X, Y)\n    return Z\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Given a current state (h doth_0 τ textitadv), the new advisory textitadv is computed as the argmax of the output score of N_textitadv on (h doth_0 τ):","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function next_adv(X::LazySet, τ, adv; algorithm_controller=DeepZ())\n    Y = cartesian_product(X, Singleton([τ]))\n    Y = normalize(Y)\n    out = forward(Y, advisory2controller[adv], algorithm_controller)\n    imax = argmax(high(out))\n    return index2advisory[imax]\nend\n\nfunction next_adv(X::Singleton, τ, adv; algorithm_controller=nothing)\n    v = vcat(element(X), τ)\n    v = normalize(v)\n    u = forward(v, advisory2controller[adv])\n    imax = argmax(u)\n    return index2advisory[imax]\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Given the new advisory, the pilot can choose acceleration ddoth_0 as follows.","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"If the new advisory is COC (1), then any acceleration from the set left-dfracg8 0 dfracg8right can be chosen, where g represents the gravitational constant 322 ft/s^2.\nFor all remaining advisories, if the previous advisory coincides with the new one and the current climb rate complies with the new advisory (e.g., doth_0 is non-positive for DNC and doth_0  1500 for CL1500), the acceleration ddoth_0 is 0.\nOtherwise, the pilot can choose acceleration ddoth_0 from the sets given below (for convenience, we also list the options for COC again).\nCOC: left-dfracg8 0 dfracg8right\nDNC: left-dfracg3 -dfrac7g24 -dfracg4right\nDND: leftdfracg4 dfrac7g24 dfracg3right\nDES1500: left-dfracg3 -dfrac7g24 -dfracg4right\nCL1500: leftdfracg4 dfrac7g24 dfracg3right\nSDES1500: left-dfracg3right\nSCL1500: leftdfracg3right\nSDES2500: left-dfracg3right\nSCL2500: leftdfracg3right","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Below we only consider the central options.","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"const g = 32.2\nconst acc_central = Dict(:COC => 0.0, :DNC => -7g / 24, :DND => 7g / 24,\n                         :DES1500 => -7g / 24, :CL1500 => 7g / 24, :SDES1500 => -g / 3,\n                         :SCL1500 => g / 3, :SDES2500 => -g / 3, :SCL2500 => g / 3);\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"The following function receives X = h doth_0 τ textitadv as well as the previous advisory textitadv, and returns the new acceleration ddoth_0:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function next_acc(X::State, adv; acc=acc_central)\n    # Project on hdot and transform units from ft/s to ft/min:\n    hdot = 60 * _interval(X.state, 2)\n\n    # New advisory:\n    adv′ = X.adv\n\n    # Check whether the current state complies with the advisory:\n    comply = hdot ⊆ advisory2set[adv′]\n\n    return (comply && adv == adv′) ? 0.0 : acc[adv′]\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Given the current system state (h doth_0 τ textitadv), the new advisory textitadv, and the acceleration ddoth_0, the new state of the system (h(k+1) doth_0(k+1) τ(k+1)textitadv(k+1)) is computed as follows:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"beginaligned\nh(k+1) = h(k) - doth_0(k) Δτ - 05 ddoth_0(k) Δτ^2 \ndoth_0(k+1) = doth_0(k) + ddoth_0(k) Δτ \nτ(k+1) = τ(k) - Δτ \ntextitadv(k+1) = textitadv\nendaligned","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"where Δτ = 1.","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"const Δτ = 1.0\nconst A = [1 -Δτ; 0 1]  # dynamics matrix (h, \\dot{h}_0)\n\nfunction VerticalCAS!(out::Vector{<:State}, kmax::Int; acc, algorithm_controller)\n    # Unpack the initial state:\n    X0 = first(out)\n    S = X0.state\n    τ = X0.τ\n    adv = X0.adv\n\n    for k in 1:kmax\n        # Get the next advisory and acceleration:\n        adv′ = next_adv(S, τ, adv; algorithm_controller=algorithm_controller)\n        X = State(S, τ, adv′)\n        hddot = next_acc(X, adv; acc=acc)\n\n        # Compute and store the next state:\n        b = [-hddot * Δτ^2 / 2, hddot * Δτ]\n        S′ = affine_map(A, S, b)\n        τ′ = τ - Δτ\n        X′ = State(S′, τ′, adv′)\n        push!(out, X′)\n\n        # Update the current state:\n        S = S′\n        τ = τ′\n        adv = adv′\n    end\n    return out\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/#Specification","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Specification","text":"","category":"section"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"The uncertain initial condition is h in -133 -129, doth_0 in -195 -225 -255 -285, τ = 25, and textitadv = textCOC:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"const h_0 = Interval(-133.0, -129.0)\nconst hdot0_0 = [-19.5, -22.5, -25.5, -28.5]\nconst τ_0 = 25.0\nconst adv_0 = :COC;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"The safety specification is that the ownship avoids entering the NMAC zone within k in 1  10 steps, i.e., h(k)  100 or h(k)  -100, for all possible choices of acceleration by the pilot.","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"unsafe_states = HalfSpace([0.0, 1.0], 100.0) ∩ HalfSpace([0.0, -1.0], 100.0)\n\npredicate_set(R) = isdisjoint(R, unsafe_states)\n\npredicate(sol) = all(predicate_set(R) for R in sol)\n\nkmax = 10\nkmax_warmup = 2;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/#Analysis","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Analysis","text":"","category":"section"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Helper function to obtain initial states from hdot0(0):","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function get_initial_states(hdot0_0i)\n    S0 = convert(Zonotope, cartesian_product(h_0, Singleton([hdot0_0i])))\n    return State(S0, τ_0, adv_0)\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Helper function to run a simulation:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function simulate_VerticalCAS(X0::State; kmax)\n    out = [X0]\n    sizehint!(out, kmax + 1)\n    VerticalCAS!(out, kmax; acc=acc_central, algorithm_controller=DeepZ())\n    return out\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Helper function to obtain an interval of dimension i:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"_interval(X::LazySet, i) = Interval(extrema(X, i)...);\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Helper function to project onto the h variable:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function _project(X::Vector{State{T}}) where {T<:Singleton}\n    return [Singleton([Xi.τ, Xi.state.element[1]]) for Xi in X]\nend\n\nfunction _project(X::Vector{State{T}}) where {T<:LazySet}\n    return [Singleton([Xi.τ]) × _interval(Xi.state, 1) for Xi in X]\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"The falsification benchmark is given below:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function benchmark(X0; kmax, silent::Bool=false)\n    res = @timed begin\n        seq = simulate_VerticalCAS(X0; kmax=kmax)\n        _project(seq)\n    end\n    sol = res.value\n    silent || print_timed(res)\n\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property is violated.\")\n        result = \"falsified\"\n    end\n\n    return sol, result\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Simulation result for all choices of velocity:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"println(\"Running flowpipe construction with central advisories:\")\nsol_all = []\nfor hdot0_0i in hdot0_0\n    println(\"Running instance hdot0(0) = $hdot0_0i:\")\n    X0 = get_initial_states(hdot0_0i)\n    benchmark(X0; kmax=kmax_warmup, silent=true)  # warm-up\n    res = @timed benchmark(X0; kmax=kmax)  # benchmark\n    sol, result = res.value\n    push!(sol_all, sol)\n    if hdot0_0i ∈ [-19.5, -22.5]\n        @assert (result == \"verified\") \"verification failed\"\n    elseif hdot0_0i ∈ [-25.5, -28.5]\n        @assert (result == \"falsified\") \"falsification failed\"\n    end\n    println(\"Total analysis time:\")\n    print_timed(res)\nend","category":"page"},{"location":"models/VerticalCAS/#Results","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Results","text":"","category":"section"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Preprocess the results (extend from time points to time intervals):","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function extend_x(X::Singleton; Δ=Δτ)\n    return LineSegment(element(X) .- [Δ, 0], element(X))\nend\n\nfunction extend_x(cp::CartesianProduct; Δ=Δτ)\n    x = first(element(first(cp)))\n    X = Interval(x - Δ, x)\n    return CartesianProduct(X, LazySets.second(cp))\nend\n\nfunction extend_x(sol_all::Vector)\n    return [vcat([extend_x(X) for X in F[1:(end - 1)]], extend_x(F[end]; Δ=0.1)) for F in sol_all]\nend\n\nsol_all = extend_x(sol_all);\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Script to plot the results:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"function plot_helper()\n    fig = plot(ylab=\"h (vertical distance)\", xlab=\"τ (time to reach horizontally)\",\n               xflip=true, leg=:topright, xticks=14:25)\n    unsafe_states_projected = cartesian_product(Universe(1),\n                                                project(unsafe_states, [2]))\n    plot!(fig, unsafe_states_projected; alpha=0.2, c=:red, lab=\"unsafe\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"Plot the results:","category":"page"},{"location":"models/VerticalCAS/","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"fig = plot_helper()\nfor (i, c) in [(1, :brown), (2, :green), (3, :orange), (4, :cyan)]\n    lab = \"h_0′ = $(hdot0_0[i])\"\n    for o in sol_all[i]\n        plot!(fig, o; lw=2, alpha=1, seriestype=:shape, c=c, lab=lab)\n        lab = \"\"\n    end\nend\nplot!(fig, xlims=(14.9, 25), ylims=(-310, -70))\n# Plots.savefig(\"VerticalCAS.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"lib/problems/#Problem-types","page":"Problem types","title":"Problem types","text":"","category":"section"},{"location":"lib/problems/#Closed-loop-system","page":"Problem types","title":"Closed-loop system","text":"","category":"section"},{"location":"lib/problems/#ClosedLoopReachability.ControlledPlant","page":"Problem types","title":"ClosedLoopReachability.ControlledPlant","text":"ControlledPlant{ST, CT, XT, DT, PT, CPRT, CPST} <: AbstractControlProblem\n\nStruct representing a closed-loop controlled system.\n\nFields\n\nivp            – initial-value problem\ncontroller     – controller\nvars           – dictionary storing state variables, input variables and                     control variables\nperiod         – control period\npostprocessing – postprocessing of the controller output\npreprocessing  – preprocessing of the controller input\n\nParameters\n\nST:  type of system\nCT:  type of controller\nXT:  type of initial condition\nDT:  type of variables\nPT:  type of period\nCPRT: type of control preprocessing\nCPST: type of control postprocessing\n\nNotes\n\nWhile typically the controller is a neural network, this struct does not prescribe the type.\n\n\n\n\n\n","category":"type"},{"location":"models/Unicycle/#Unicycle","page":"Unicycle","title":"Unicycle","text":"","category":"section"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"The Unicycle benchmark models a unicycle vehicle [AKM17].","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"(Image: )","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: UniformAdditivePostprocessing\nusing Plots: plot, plot!, lens!, bbox","category":"page"},{"location":"models/Unicycle/#Model","page":"Unicycle","title":"Model","text":"","category":"section"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"There are 4 state variables (x_1 x_2 x_3 x_4), where (x_1 x_2) describe the x and y coordinates in the plane, x_3 is the velocity, and x_4 is the steering angle. The dynamics are given as follows:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"beginaligned\ndotx_1 = x_4 cos(x_3) \ndotx_2 = x_4 sin(x_3) \ndotx_3 = u_2 \ndotx_4 = u_1 + w\nendaligned","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"where w is a bounded error in the range 10^4 10^4, which we model as a nondeterministically assigned constant for simplicity.","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"vars_idx = Dict(:states => 1:4, :disturbances => [5], :controls => 6:7)\n\n@taylorize function Unicycle!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, w, u₁, u₂ = x\n\n    dx[1] = x₄ * cos(x₃)\n    dx[2] = x₄ * sin(x₃)\n    dx[3] = u₂\n    dx[4] = u₁ + w\n    dx[5] = zero(x[5])\n    dx[6] = zero(x[6])\n    dx[7] = zero(x[7])\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"We are given a neural-network controller with 1 hidden layer of 500 neurons and ReLU activations in all layers, including the output layer. The controller has 4 inputs (the state variables) and 2 outputs (u_1 and u_2). The output of the neural network N(x) needs to be normalized in order to obtain u, namely (u_1 u_2) = N(x) - (20 20).","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"path = @current_path(\"Unicycle\", \"Unicycle_controller.polar\")\ncontroller = read_POLAR(path)\n\ncontrol_postprocessing = UniformAdditivePostprocessing(-20.0);\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"The control period is 0.2 time units.","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"period = 0.2;\nnothing #hide","category":"page"},{"location":"models/Unicycle/#Specification","page":"Unicycle","title":"Specification","text":"","category":"section"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"The uncertain initial condition is:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"x_1  95955 x_2  45445 x_3  21211 x_4  15151","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"X₀ = Hyperrectangle(low=[9.5, -4.5, 2.1, 1.5, -1e-4],\n                    high=[9.55, -4.45, 2.11, 1.51, 1e-4])\nU₀ = ZeroSet(2);\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"The control problem is:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"ivp = @ivp(x' = Unicycle!(x), dim: 7, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period;\n                       postprocessing=control_postprocessing);\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"The specification is to reach the goal region","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"x_1  0606 x_2  0202 x_3  006006 x_4  0303","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"until a time horizon of 10 time units. A sufficient condition for guaranteed verification is to overapproximate the result at the end with a hyperrectangle.","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"goal_set = cartesian_product(Hyperrectangle(zeros(4), [0.6, 0.2, 0.06, 0.3]),\n                             Universe(3))\n\npredicate_set(R) = overapproximate(R, Hyperrectangle, tend(R)) ⊆ goal_set\n\npredicate(sol) = all(predicate_set(F[end]) for F in sol if T ∈ tspan(F))\n\nT = 10.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/Unicycle/#Analysis","page":"Unicycle","title":"Analysis","text":"","category":"section"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"algorithm_plant = TMJets(abstol=1e-1, orderT=3, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"To propagate sets through the neural network, we use the DeepZ algorithm. We also use an additional splitting strategy to increase the precision.","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"algorithm_controller = DeepZ()\nsplitter = BoxSplitter([3, 1, 7, 1]);\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"The verification benchmark is given below:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"function benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"Run the verification benchmark and compute some simulations:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"benchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=5, include_vertices=false)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Unicycle/#Results","page":"Unicycle","title":"Results","text":"","category":"section"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"Preprocess the results:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"solz = overapproximate(sol, Zonotope)\nTint = try convert(Int, T) catch; T end;\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"Script to plot the results:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"function plot_helper(vars; show_simulation::Bool=true)\n    fig = plot()\n    plot!(fig, project(goal_set, vars); color=:cyan, alpha=0.5, lab=\"goal\")\n    plot!(fig, solz; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀, vars); color=:cornflowerblue, alpha=1, lab=\"X₀\")\n    lab = \"reach set at t = $Tint\"\n    for F in sol\n        if T ∈ tspan(F)\n            plot!(fig, overapproximate(F[end], Zonotope, tend(F));\n                  vars=vars, color=:orange, lab=lab)\n            lab = \"\"\n        end\n    end\n    if show_simulation\n        plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    end\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"Plot the results:","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"vars = (1, 2)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"x₁\", ylab=\"x₂\", leg=:bottomleft)\nlens!(fig, [9.49, 9.56], [-4.51, -4.44]; inset=(1, bbox(0.65, 0.05, 0.25, 0.25)),\n      lc=:black, xticks=[9.5, 9.55], yticks=[-4.5, -4.45], subplot=2)\nlens!(fig, [0.3, 0.7], [-0.25, 0.25]; inset=(1, bbox(0.1, 0.3, 0.25, 0.25)),\n      lc=:black, xticks=[0.4, 0.6], yticks=[-0.2, 0.2], subplot=3)\n# Plots.savefig(fig, \"Unicycle-x1-x2.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Unicycle/","page":"Unicycle","title":"Unicycle","text":"vars = (3, 4)\nfig = plot_helper(vars; show_simulation=false)\nplot!(fig; xlab=\"x₃\", ylab=\"x₄\", leg=:bottom)\nlens!(fig, [2.09, 2.12], [1.495, 1.515]; inset=(1, bbox(0.72, 0.54, 0.25, 0.25)),\n      lc=:black, xticks=[2.1, 2.11], yticks=[1.5, 1.51], subplot=2)\nlens!(fig, [-0.1, 0.03], [-0.4, -0.15]; inset=(1, bbox(0.1, 0.1, 0.25, 0.25)),\n      lc=:black, xticks=[-0.08, 0], yticks=[-0.3, -0.2], subplot=3)\n# Plots.savefig(fig, \"Unicycle-x3-x4.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/InvertedPendulum/#Inverted-Pendulum","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"","category":"section"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"The Inverted Pendulum benchmark is a classical model of motion. We consider two scenarios, which we refer to as the verification and the falsification scenario.","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: SingleEntryVector, Specification, NoSplitter\nusing Plots: plot, plot!, xlims!, ylims!, lens!, bbox, savefig","category":"page"},{"location":"models/InvertedPendulum/#Model","page":"Inverted Pendulum","title":"Model","text":"","category":"section"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"A ball of mass m is attached to a massless beam of length L. The beam is actuated with a torque T. We assume viscous friction with coefficient c.","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"The governing equation of motion can be obtained as follows:","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"ddotθ = dfracgL sin(θ) + dfrac1m L^2 (T - c dotθ)","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"where θ is the angle that the link makes with the upward vertical axis, dotθ is the angular velocity, and g is the gravitational acceleration. The state vector is (θ dotθ). The model constants are chosen as m = L = 05, c = 0, and g = 1.","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"(Image: )","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"vars_idx = Dict(:states => 1:2, :controls => 3)\n\nconst m = 0.5\nconst L = 0.5\nconst c = 0.0\nconst g = 1.0\nconst gL = g / L\nconst mL = 1 / (m * L^2)\n\n@taylorize function InvertedPendulum!(dx, x, p, t)\n    θ, θ′, T = x\n\n    dx[1] = θ′\n    dx[2] = gL * sin(θ) + mL * (T - c * θ′)\n    dx[3] = zero(T)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"We are given a neural-network controller with 2 hidden layers of 25 neurons each and ReLU activations. The controller has 2 inputs (the state variables) and 1 output (T).","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"path = @current_path(\"InvertedPendulum\", \"InvertedPendulum_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"The control period is 0.05 time units.","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"period = 0.05;\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/#Specification","page":"Inverted Pendulum","title":"Specification","text":"","category":"section"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"The following script creates a different problem instance for the two scenarios, respectively.","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"function InvertedPendulum_spec(verification::Bool)\n    # The uncertain initial condition is ``\\dot{θ} \\in [0, 0.2]``, and ``θ``\n    # depends on the scenario.\n    if verification\n        # ``θ \\in [1, 1.175]``.\n        X₀ = Hyperrectangle(low=[1.0, 0], high=[1.175, 0.2])\n    else\n        # ``θ \\in [1, 1.2]``. We choose a single point (here: the top-most one):\n        X₀ = Singleton(high(BallInf([1.1, 0.1], 0.1)))\n    end\n    U₀ = ZeroSet(1);\n\n    # The control problem is:\n\n    ivp = @ivp(x' = InvertedPendulum!(x), dim: 3, x(0) ∈ X₀ × U₀)\n    prob = ControlledPlant(ivp, controller, vars_idx, period);\n\n    # The safety specification is that ``θ ∈ [0, 1]`` for ``t ∈ [0.5, 1]``\n    # (i.e., the control periods ``10 ≤ k ≤ 20``). A sufficient condition for a\n    # guaranteed verdict is to overapproximate the result with hyperrectangles.\n\n    if verification\n        unsafe_states = UnionSet(HalfSpace(SingleEntryVector(1, 3, -1.0), -1.0),\n                                 HalfSpace(SingleEntryVector(1, 3, 1.0), 0.0))\n    else\n        unsafe_states = HalfSpace(SingleEntryVector(1, 3, -1.0), -1.0)\n    end\n\n    function predicate_set_safe(R)\n        t = tspan(R)\n        return t.hi <= 0.5 ||\n            isdisjoint(overapproximate(R, Hyperrectangle), unsafe_states)\n    end\n\n    function predicate_safe(sol; silent::Bool=false)\n        for F in sol\n            t = tspan(F)\n            if t.hi <= 0.5\n                continue\n            end\n            for R in F\n                if !predicate_set_safe(R)\n                    silent || println(\"  Potential violation for time range $(tspan(R)).\")\n                    return false\n                end\n            end\n        end\n        return true\n    end\n\n    function predicate_set_unsafe(R)\n        t = tspan(R)\n        return t.lo >= 0.5 && t.hi <= 1.0 &&\n            overapproximate(R, Hyperrectangle) ⊆ unsafe_states\n    end\n\n    function predicate_unsafe(sol; silent::Bool=false)\n        for F in sol\n            t = tspan(F)\n            if t.hi < 0.5\n                continue\n            end\n            for R in F\n                if predicate_set_unsafe(R)\n                    silent || println(\"  Violation for time range $(tspan(R)).\")\n                    return true\n                end\n            end\n        end\n        return false\n    end\n\n    if verification\n        predicate = predicate_safe\n    else\n        predicate = predicate_unsafe\n    end\n\n    if verification\n        T = 1.0\n    else\n        T = 11 * period  # falsification can run for a shorter time horizon\n    end\n\n    spec = Specification(T, predicate, unsafe_states)\n\n    return prob, spec\nend\n\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/#Analysis","page":"Inverted Pendulum","title":"Analysis","text":"","category":"section"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm. We also use an additional splitting strategy to increase the precision. These algorithms are defined later for each scenario. To propagate sets through the neural network, we use the DeepZ algorithm:","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"The falsification benchmark is given below:","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"function benchmark(prob, spec; T, algorithm_plant, splitter, verification, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    if verification\n        res = @timed spec.predicate(sol; silent=silent)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is verified.\")\n            result = \"verified\"\n        else\n            silent || println(\"  The property may be violated.\")\n            result = \"not verified\"\n        end\n    else\n        res = @timed spec.predicate(sol; silent=silent)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is violated.\")\n            result = \"falsified\"\n        else\n            silent || println(\"  The property may be satisfied.\")\n            result = \"not falsified\"\n        end\n    end\n\n    return sol, result\nend\n\nfunction run(; verification::Bool)\n    if verification\n        println(\"# Running analysis with verification scenario\")\n        algorithm_plant = TMJets(abstol=1e-9, orderT=5, orderQ=1)\n        splitter = BoxSplitter([[1.1, 1.16], [0.09, 0.145, 0.18]])\n    else\n        println(\"# Running analysis with falsification scenario\")\n        algorithm_plant = TMJets(abstol=1e-7, orderT=4, orderQ=1)\n        splitter = NoSplitter()\n    end\n    prob, spec = InvertedPendulum_spec(verification)\n\n    # Run the verification/falsification benchmark:\n    benchmark(prob, spec; T=T_warmup, algorithm_plant=algorithm_plant, splitter=splitter,\n              verification=verification, silent=true)  # warm-up\n    res = @timed benchmark(prob, spec; T=spec.T, algorithm_plant=algorithm_plant,  # benchmark\n                           splitter=splitter, verification=verification)\n    sol, result = res.value\n    if verification\n        @assert (result == \"verified\") \"verification failed\"\n    else\n        @assert (result == \"falsified\") \"falsification failed\"\n    end\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    trajectories = verification ? 10 : 1\n    res = @timed simulate(prob; T=spec.T, trajectories=trajectories,\n                          include_vertices=verification)\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim, prob, spec\nend;\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"Run the analysis script for the verification scenario:","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"sol_v, sim_v, prob_v, spec_v = run(verification=true);\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"Run the analysis script for the falsification scenario:","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"sol_f, sim_f, prob_f, spec_f = run(verification=false);\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/#Results","page":"Inverted Pendulum","title":"Results","text":"","category":"section"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"Script to plot the results:","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"function plot_helper(sol, sim, prob, spec, verification)\n    vars = (0, 1)\n    fig = plot(leg=:topright)\n    lab = \"unsafe\"\n    unsafe_states = spec.ext isa UnionSet ? spec.ext : [spec.ext]\n    for B in unsafe_states\n        unsafe_states_projected = cartesian_product(Interval(0.5, 1.0), project(B, [vars[2]]))\n        plot!(fig, unsafe_states_projected; color=:red, alpha=:0.2, lab=lab)\n        lab = \"\"\n    end\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    initial_states_projected =\n        cartesian_product(Singleton([0.0]), project(initial_state(prob), [vars[2]]))\n    plot!(fig, initial_states_projected; c=:cornflowerblue, alpha=1, m=:none, lw=7, lab=\"X₀\")\n    lab_sim = verification ? \"\" : \"simulation\"\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    xlims!(0, spec.T)\n    plot!(fig; xlab=\"t\", ylab=\"θ\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"Plot the results:","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"fig = plot_helper(sol_v, sim_v, prob_v, spec_v, true)\nylims!(fig, 0.5, 1.2)\nlens!(fig, [0.49, 0.52], [0.99, 1.01]; inset=(1, bbox(0.1, 0.6, 0.3, 0.3)),\n      lc=:black, xticks=[0.5], yticks=[1.0], subplot=3)\n# Plots.savefig(fig, \"InvertedPendulum_verification.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/InvertedPendulum/","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"fig = plot_helper(sol_f, sim_f, prob_f, spec_f, false)\nylims!(fig, 0.95, 1.22)\n# Plots.savefig(fig, \"InvertedPendulum_falsification.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/AttitudeControl/#Attitude-Control","page":"Attitude Control","title":"Attitude Control","text":"","category":"section"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"The Attitude Control benchmark models a rigid-body system [PPR04].","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing Plots: plot, plot!","category":"page"},{"location":"models/AttitudeControl/#Model","page":"Attitude Control","title":"Model","text":"","category":"section"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"There are 6 state variables: (ω_1 ω_2 ω_3 ψ_1 ψ_2 ψ_3). The system dynamics are given as follows:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"beginaligned\ndotω_1 = 025 (u_0 + ω_2 ω_3) \ndotω_2 = 05 (u_1 - 3 ω_1 ω_3) \ndotω_3 = u_2 + 2 ω_1 ω_2) \ndotψ_1 = 05 (ω₂ (ξ - ψ₃) + ω₃ (ξ + ψ₂) + ω₁ (ξ + 1)) \ndotψ_2 = 05 (ω₁ (ξ + ψ₃) + ω₃ (ξ - ψ₁) + ω₂ (ξ + 1)) \ndotψ_3 = 05 (ω₁ (ξ - ψ₂) + ω₂ (ξ + ψ₁) + ω₃ (ξ + 1))\nendaligned","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"where ω = (ω_1 ω_2 ω_3) is the angular velocity in a body-fixed frame, ψ = (ψ_1 ψ_2 ψ_3) are the Rodrigues parameters, and ξ = ψ₁^2 + ψ₂^2 + ψ₃^2.","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"vars_idx = Dict(:states => 1:6, :controls => 7:9)\n\n@taylorize function AttitudeControl!(dx, x, p, t)\n    ω₁, ω₂, ω₃, ψ₁, ψ₂, ψ₃, u₀, u₁, u₂ = x\n\n    ξ = ψ₁^2 + ψ₂^2 + ψ₃^2\n\n    dx[1] = 0.25 * (u₀ + ω₂ * ω₃)\n    dx[2] = 0.5 * (u₁ - 3 * ω₁ * ω₃)\n    dx[3] = u₂ + 2 * ω₁ * ω₂\n    dx[4] = 0.5 * (  ω₂ * (ξ - ψ₃)\n                   + ω₃ * (ξ + ψ₂)\n                   + ω₁ * (ξ + 1))\n    dx[5] = 0.5 * (  ω₁ * (ξ + ψ₃)\n                   + ω₃ * (ξ - ψ₁)\n                   + ω₂ * (ξ + 1))\n    dx[6] = 0.5 * (  ω₁ * (ξ - ψ₂)\n                   + ω₂ * (ξ + ψ₁)\n                   + ω₃ * (ξ + 1))\n    dx[7] = zero(u₀)\n    dx[8] = zero(u₁)\n    dx[9] = zero(u₂)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"We are given a neural-network controller with 3 hidden layers of 64 neurons each and sigmoid activations. The controller has 6 inputs (the state variables) and 3 outputs (u_0 u_1 u_2).","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"path = @current_path(\"AttitudeControl\", \"AttitudeControl_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"The control period is 0.1 time units.","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"period = 0.1;\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/#Specification","page":"Attitude Control","title":"Specification","text":"","category":"section"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"The uncertain initial condition is:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"X₀ = Hyperrectangle(low=[-0.45, -0.55, 0.65, -0.75, 0.85, -0.65],\n                    high=[-0.44, -0.54, 0.66, -0.74, 0.86, -0.64])\nU₀ = ZeroSet(3);\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"The control problem is:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"ivp = @ivp(x' = AttitudeControl!(x), dim: 9, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"The safety specification is that a set of unsafe states should not be reached within 3 time units. A sufficient condition for guaranteed verification is to overapproximate the result with hyperrectangles.","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"unsafe_states = cartesian_product(\n    Hyperrectangle(low=[-0.2, -0.5, 0,   -0.7, 0.7, -0.4],\n                   high=[0,   -0.4, 0.2, -0.6, 0.8, -0.2]),\n    Universe(3))\n\npredicate(sol) = isdisjoint(overapproximate(sol, Hyperrectangle), unsafe_states);\n\nT = 3.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/#Analysis","page":"Attitude Control","title":"Analysis","text":"","category":"section"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"algorithm_plant = TMJets(abstol=1e-4, orderT=5, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"To propagate sets through the neural network, we use the DeepZ algorithm:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"The verification benchmark is given below:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"function benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"Run the verification benchmark and compute some simulations:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"benchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=10, include_vertices=false)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/#Results","page":"Attitude Control","title":"Results","text":"","category":"section"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"Script to plot the results:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"function plot_helper(vars)\n    fig = plot()\n    plot!(fig, project(unsafe_states, vars); color=:red, alpha=:0.2,\n          lab=\"unsafe\", leg=:topleft)\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"Plot the results:","category":"page"},{"location":"models/AttitudeControl/","page":"Attitude Control","title":"Attitude Control","text":"vars = (1, 2)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"ω₁\", ylab=\"ω₂\")\n# Plots.savefig(fig, \"AttitudeControl.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/Quadrotor/#Quadrotor","page":"Quadrotor","title":"Quadrotor","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"The Quadrotor benchmark is a model of a flying drone with four rotors.","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"(Image: )","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: SingleEntryVector\nusing Plots: plot, plot!","category":"page"},{"location":"models/Quadrotor/#Model","page":"Quadrotor","title":"Model","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"There are 12 state variables (x_1  x_12), where (x_1 x_2) is the inertial position (north and east), x_3 is the altitude, (x_4 x_5 x_6) is the velocity (longitudinal, lateral, vertical), (x_7 x_8 x_9) is the (roll, pitch, yaw) angle, and (x_10 x_11 x_12) is the (roll, pitch, yaw) rate. The control inputs (u_1 u_2 u_3) represent the torque. For more details we refer to Beard [Bea08].","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"vars_idx = Dict(:states => 1:12, :controls => 13:15)\n\nconst g = 9.81\nconst m = 1.4\nconst Jx = 0.054\nconst Jy = 0.054\nconst Jz = 0.104\nconst Cyzx = (Jy - Jz) / Jx\nconst Czxy = (Jz - Jx) / Jy\nconst Cxyz = (Jx - Jy) / Jz\nconst τψ = 0.0\nconst Tz = τψ / Jz;\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"The differential equations can be simplified using knowledge about the model constants:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"@taylorize function Quadrotor!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, x₅, x₆, x₇, x₈, x₉, x₁₀, x₁₁, x₁₂, u₁, u₂, u₃ = x\n\n    F₁ = g + u₁ / m\n    Tx = u₂ / Jx\n    Ty = u₃ / Jy\n    sx7 = sin(x₇)\n    cx7 = cos(x₇)\n    sx8 = sin(x₈)\n    cx8 = cos(x₈)\n    sx9 = sin(x₉)\n    cx9 = cos(x₉)\n    sx7sx9 = sx7 * sx9\n    sx7cx9 = sx7 * cx9\n    cx7sx9 = cx7 * sx9\n    cx7cx9 = cx7 * cx9\n    sx7cx8 = sx7 * cx8\n    cx7cx8 = cx7 * cx8\n    sx7_cx8 = sx7 / cx8\n    x4cx8 = cx8 * x₄\n    xdot9 = sx7_cx8 * x₁₁\n\n    dx[1] = (cx9 * x4cx8 + (sx7cx9 * sx8 - cx7sx9) * x₅) + (cx7cx9 * sx8 + sx7sx9) * x₆\n    dx[2] = (sx9 * x4cx8 + (sx7sx9 * sx8 + cx7cx9) * x₅) + (cx7sx9 * sx8 - sx7cx9) * x₆\n    dx[3] = (sx8 * x₄ - sx7cx8 * x₅) - cx7cx8 * x₆\n    dx[4] = -x₁₁ * x₆ - g * sx8\n    dx[5] = x₁₀ * x₆ + g * sx7cx8\n    dx[6] = (x₁₁ * x₄ - x₁₀ * x₅) + (g * cx7cx8 - F₁)\n    dx[7] = x₁₀ + sx8 * xdot9\n    dx[8] = cx7 * x₁₁\n    dx[9] = xdot9\n    dx[10] = Tx\n    dx[11] = Ty\n    dx[12] = zero(x[12])\n    dx[13] = zero(u₁)\n    dx[14] = zero(u₂)\n    dx[15] = zero(u₃)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"We are given a neural-network controller with 3 hidden layers of 64 neurons each and sigmoid activations. The controller has 12 inputs (the state variables) and 3 outputs (u_1 u_2 u_3).","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"path = @current_path(\"Quadrotor\", \"Quadrotor_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"The control period is 0.1 time units.","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"period = 0.1;\nnothing #hide","category":"page"},{"location":"models/Quadrotor/#Specification","page":"Quadrotor","title":"Specification","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"We consider a smaller uncertain initial condition than originally proposed; specifically, the set is a hyperrectangle with 1% of the original radius:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"r = [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0, 0, 0, 0, 0, 0]  # original radius\nX₀ = Hyperrectangle(zeros(12), 0.01 * r)\nU₀ = ZeroSet(3);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"The control problem is:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"ivp = @ivp(x' = Quadrotor!(x), dim: 15, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"The specification is to stabilize the attitude x_3 to the goal region 094 106 until a time horizon of 50 time units. A sufficient condition for guaranteed verification is to overapproximate the result at the end with a hyperrectangle.","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"goal_states = HPolyhedron([HalfSpace(SingleEntryVector(3, 15, -1.0), -0.94),\n                           HalfSpace(SingleEntryVector(3, 15, 1.0), 1.06)])\n\npredicate_set(R) = overapproximate(R, Hyperrectangle) ⊆ goal_states\n\npredicate(sol) = all(predicate_set(F[end]) for F in sol if T ∈ tspan(F))\n\nT = 5.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/Quadrotor/#Analysis","page":"Quadrotor","title":"Analysis","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"algorithm_plant = TMJets(abstol=1e-1, orderT=3, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"To propagate sets through the neural network, we use the DeepZ algorithm:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"The verification benchmark is given below:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"function benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Run the verification benchmark and compute some simulations:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"benchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=1, include_vertices=false)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/#Results","page":"Quadrotor","title":"Results","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Script to plot the results:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"function plot_helper(vars)\n    goal_states_projected = cartesian_product(Interval(0, T),\n                                              project(goal_states, [vars[2]]))\n    fig = plot()\n    plot!(fig, goal_states_projected; color=:cyan, lab=\"goal\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Plot the results:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"vars = (0, 3)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"t\", ylab=\"x₃\")\n# Plots.savefig(fig, \"Quadrotor.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/ACC/#Adaptive-Cruise-Control-(ACC)","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The Adaptive Cruise Control (ACC) benchmark models a car that drives at a set velocity and maintains a safe distance from a lead car by adjusting the longitudinal acceleration [TCL+19].","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"(Image: )","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"using ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: FunctionPreprocessing\nusing Plots: plot, plot!","category":"page"},{"location":"models/ACC/#Model","page":"Adaptive Cruise Control (ACC)","title":"Model","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The cars' dynamics are modeled as follows:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"beginaligned\ndotx_lead = v_lead \ndotv_lead = γ_lead \ndotγ_lead = -2 γ_lead + 2 a_lead - u v_lead^2 \ndotx_ego = v_ego \ndotv_ego = γ_ego \ndotγ_ego = -2 γ_ego + 2 a_ego - u v_ego^2\nendaligned","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"where u = 00001 is the friction parameter, and for each car i  ego lead we have that x_i is the position, v_i is the velocity, γ_i is the acceleration, and a_i is the control input for the acceleration.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"vars_idx = Dict(:states => 1:6, :controls => 7)\n\nconst u = 0.0001\nconst a_lead = -2.0\n\n@taylorize function ACC!(dx, x, p, t)\n    v_lead = x[2]  # lead car velocity\n    γ_lead = x[3]  # lead car acceleration\n    v_ego = x[5]  # ego car velocity\n    γ_ego = x[6]  # ego car acceleration\n    a_ego = x[7]  # ego car acceleration control input\n\n    # Lead-car dynamics:\n    dx[1] = v_lead\n    dx[2] = γ_lead\n    dx[3] = 2 * (a_lead - γ_lead) - u * v_lead^2\n\n    # Ego-car dynamics:\n    dx[4] = v_ego\n    dx[5] = γ_ego\n    dx[6] = 2 * (a_ego - γ_ego) - u * v_ego^2\n\n    dx[7] = zero(a_ego)\n    return dx\nend;\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"We are given two neural-network controllers with 5 hidden layers of 20 neurons each. One controller uses ReLU activations and the other controller uses tanh activations. Both controllers have 5 inputs (v_set T_gap v_ego D_rel v_rel) and one output (a_ego), where v_set = 30 is the ego car's set velocity, T_gap = 14, D_rel = x_lead - x_ego is the distance between the cars, and v_rel = v_lead - v_ego is the distance between the velocities.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"path = @current_path(\"ACC\", \"ACC_controller_relu.polar\")\ncontroller_relu = read_POLAR(path)\n\npath = @current_path(\"ACC\", \"ACC_controller_tanh.polar\")\ncontroller_tanh = read_POLAR(path);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The controller input is (v_set T_gap v_ego D_rel v_rel), for which we define a transformation matrix M.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"v_set = 30.0\nT_gap = 1.4\nM = zeros(3, 6)\nM[1, 5] = 1.0\nM[2, 1] = 1.0\nM[2, 4] = -1.0\nM[3, 2] = 1.0\nM[3, 5] = -1.0\nfunction preprocess(X::LazySet)  # version for set computations\n    Y1 = Singleton([v_set, T_gap])\n    Y2 = linear_map(M, X)\n    return cartesian_product(Y1, Y2)\nend\nfunction preprocess(X::AbstractVector)  # version for simulations\n    Y1 = [v_set, T_gap]\n    Y2 = M * X\n    return vcat(Y1, Y2)\nend\ncontrol_preprocessing = FunctionPreprocessing(preprocess);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The control period is 0.1 time units.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"period = 0.1;\nnothing #hide","category":"page"},{"location":"models/ACC/#Specification","page":"Adaptive Cruise Control (ACC)","title":"Specification","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The uncertain initial condition is:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"beginaligned\nx_lead  90 110 v_lead  32 322 γ_lead = 0 \nx_ego  10 11 v_ego  30 302 γ_ego = 0\nendaligned","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"X₀ = Hyperrectangle(low=[90, 32, 0, 10, 30, 0],\n                    high=[110, 32.2, 0, 11, 30.2, 0])\nU₀ = ZeroSet(1);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The control problem (parametric in the controller) is:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"ivp = @ivp(x' = ACC!(x), dim: 7, x(0) ∈ X₀ × U₀)\nproblem(controller) = ControlledPlant(ivp, controller, vars_idx, period;\n                                      preprocessing=control_preprocessing);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"We consider a scenario where both cars are driving safely and the lead car suddenly slows down with a_lead = -2. We want to verify that there is no collision in the following 5 time units, i.e., the ego car must maintain a safe distance D_safe from the lead car. Formally, the safety specification is D_rel  D_safe, where D_safe = D_default + T_gap  v_ego and D_default = 10. After substitution, the specification reduces to x_lead - x_ego - T_gap  v_ego  D_default. A sufficient condition for guaranteed verification is to overapproximate the result with hyperrectangles.","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"D_default = 10.0\nd_rel = [1.0, 0, 0, -1, 0, 0, 0]\nd_safe = [0, 0, 0, 0, T_gap, 0, 0]\nd_prop = d_rel - d_safe\nsafe_states = HalfSpace(-d_prop, -D_default)\n\npredicate(sol) = overapproximate(sol, Hyperrectangle) ⊆ safe_states\n\nT = 5.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"page"},{"location":"models/ACC/#Analysis","page":"Adaptive Cruise Control (ACC)","title":"Analysis","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"algorithm_plant = TMJets(abstol=1e-3, orderT=5, orderQ=1);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"To propagate sets through the neural network, we use the DeepZ algorithm:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"algorithm_controller = DeepZ();\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The verification benchmark is given below:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"function benchmark(prob; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"For each controller we execute the same analysis script, which runs the verification benchmark and computes simulations:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"function run(; use_relu_controller::Bool)\n    if use_relu_controller\n        println(\"# Running analysis with ReLU controller\")\n        prob = problem(controller_relu)\n    else\n        println(\"# Running analysis with tanh controller\")\n        prob = problem(controller_tanh)\n    end\n\n    # Run the verification benchmark:\n    benchmark(prob; T=T_warmup, silent=true)  # warm-up\n    res = @timed benchmark(prob; T=T)  # benchmark\n    sol, result = res.value\n    @assert (result == \"verified\") \"verification failed\"\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    res = @timed simulate(prob; T=T, trajectories=10, include_vertices=true)\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim\nend;\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"Run the analysis script for the ReLU controller:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"sol_relu, sim_relu = run(use_relu_controller=true);\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"Run the analysis script for the tanh controller:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"sol_tanh, sim_tanh = run(use_relu_controller=false);\nnothing #hide","category":"page"},{"location":"models/ACC/#Results","page":"Adaptive Cruise Control (ACC)","title":"Results","text":"","category":"section"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"Script to plot the results:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"function plot_helper(sol, sim)\n    fig = plot(leg=(0.4, 0.3))\n    for F in sol, R in F\n        # Subdivide the reach sets in time to obtain more precise plots:\n        R = overapproximate(R, Zonotope; ntdiv=5)\n        R_rel = linear_map(Matrix(d_rel'), R)\n        plot!(fig, R_rel; vars=(0, 1), c=:red, lw=0, alpha=0.4)\n    end\n\n    solz = overapproximate(flowpipe(sol), Zonotope)\n    fp_safe = affine_map(Matrix(d_safe'), solz, [D_default])\n    plot!(fig, fp_safe; vars=(0, 1), c=:blue, lw=0, alpha=0.4)\n\n    output_map_rel = x -> dot(d_rel, x)\n    plot_simulation!(fig, sim; output_map=output_map_rel, color=:red, lab=\"Drel\")\n\n    output_map_safe = x -> dot(d_safe, x) + D_default\n    plot_simulation!(fig, sim; output_map=output_map_safe, color=:blue, lab=\"Dsafe\")\n\n    plot!(fig; xlab=\"time\")\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"Plot the results:","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"fig = plot_helper(sol_relu, sim_relu)\n# Plots.savefig(fig, \"ACC-ReLU.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"page"},{"location":"models/ACC/","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"fig = plot_helper(sol_tanh, sim_tanh)\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n# savefig(fig, \"ACC-tanh.png\")  # command to save the plot to a file","category":"page"},{"location":"lib/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"lib/solvers/#Flowpipe-computation","page":"Solvers","title":"Flowpipe computation","text":"","category":"section"},{"location":"lib/solvers/#CommonSolve.solve","page":"Solvers","title":"CommonSolve.solve","text":"solve(prob::AbstractControlProblem, args...; kwargs...)\n\nSolve the control problem defined by prob.\n\nInput\n\nprob – controlled problem\n\nAdditional options are passed as arguments or keyword arguments; see the notes below for details. See the online documentation for examples.\n\nOutput\n\nThe solution of a reachability problem controlled by a periodic controller. The control signals are stored in the ext field with each flowpipe.\n\nNotes\n\nMandatory arguments\n\nUse the tspan keyword argument to specify the time span (start time and time\n\nhorizon); it can be a tuple, an interval, or a vector with two components. Alternatively, use the T keyword argument to specify only the time horizon, in which case the start time is assumed to be zero.\n\nUse the algorithm_plant keyword argument to specify the algorithm for the\n\nplant.\n\nUse the algorithm_controller keyword argument to specify the algorithm for\n\nthe controller.\n\nOptional arguments\n\nUse the splitter and input_splitter keyword arguments to specify a\n\nsplitter.\n\nDefault: NoSplitter()\n\nUse the reconstruction_method keyword arguments to specify a reconstruction\n\nmethod for the interface between plant and controller.\n\nDefault: TaylorModelReconstructor()\n\n\n\n\n\n","category":"function"},{"location":"lib/solvers/#Trajectory-simulation","page":"Solvers","title":"Trajectory simulation","text":"","category":"section"},{"location":"lib/solvers/#ClosedLoopReachability.simulate","page":"Solvers","title":"ClosedLoopReachability.simulate","text":"simulate(cp::AbstractControlProblem, args...; kwargs...)\n\nSimulate a controlled system for a family of random trajectories.\n\nInput\n\ncp           – controlled problem\ntrajectories – (optional, default: 10) number of simulated trajectories\n\nOutput\n\nAn object of type EnsembleSimulationSolution.\n\nNotes\n\nThis function uses the ensemble simulations feature from OrdinaryDiffEq.jl.\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"M. E. Akintunde, E. Botoeva, P. Kouvaros and A. Lomuscio. Formal Verification of Neural Agents in Non-deterministic Environments. In: Autonomous Agents and Multiagent Systems (AAMAS), edited by A. E. Seghrouchni, G. Sukthankar, B. An and N. Yorke-Smith (IFAAMAS, 2020); pp. 25–33.\n\n\n\nM. Althoff, M. Koschi and S. Manzinger. CommonRoad: Composable benchmarks for motion planning on roads. In: Intelligent Vehicles (IV) (IEEE, 2017); pp. 719–726.\n\n\n\nR. W. Beard. Quadrotor dynamics and control. Technical Report 1325 (Brigham Young University, 2008).\n\n\n\nM. Jankovic, D. Fontaine and P. V. Kokotovic. TORA example: cascade- and passivity-based control designs. Transactions on Control Systems Technology 4, 292–297 (1996).\n\n\n\nK. D. Julian and M. J. Kochenderfer. A Reachability Method for Verifying Dynamical Systems with Deep Neural                   Network Controllers. CoRR abs/1903.00520 (2019), arXiv:1903.00520.\n\n\n\nS. Prajna, P. A. Parrilo and A. Rantzer. Nonlinear control synthesis by convex optimization. Transactions on Automatic Control 49, 310–314 (2004).\n\n\n\nU. J. Ravaioli, J. Cunningham, J. McCarroll, V. Gangal, K. Dunlap and K. L. Hobbs. Safe reinforcement learning benchmark environments for aerospace control systems. In: Aerospace Conference (AERO) (IEEE, 2022); pp. 1–20.\n\n\n\nH.-D. Tran, F. Cai, D. M. Lopez, P. Musau, T. T. Johnson and X. D. Koutsoukos. Safety Verification of Cyber-Physical Systems with Reinforcement Learning                   Control. Transactions on Embedded Computing Systems 18, 105:1–105:22 (2019).\n\n\n\n","category":"page"}]
}
