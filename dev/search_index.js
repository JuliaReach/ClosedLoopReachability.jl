var documenterSearchIndex = {"docs":
[{"location":"models/TORA/#Translational-Oscillations-by-a-Rotational-Actuator-(TORA)","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Translational Oscillations by a Rotational Actuator (TORA)","text":"The TORA benchmark models a cart attached to a wall with a spring. The cart is free to move on a friction-less surface and has a weight attached to an arm, which is free to rotate about an axis. This serves as the control input to stabilize the cart at the origin x = 0 [JFK96].\n\n(Image: )\n\nWe consider two different scenarios. In the first scenario, we have a safety specification. In the other scenario, we have a reachability specification.\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: UniformAdditivePostprocessing, NoSplitter, LinearMapPostprocessing\nusing Plots: plot, plot!, lens!, bbox\n\nThe following option determines whether the verification settings should be used in the first scenario. The verification settings are chosen to show that the safety property is satisfied, which is expensive in this case. Concretely, we split the initial states into small chunks and run many analyses. Without the verification settings, the analysis is only run for a short time horizon.\n\nconst verification = false;\nnothing #hide","category":"section"},{"location":"models/TORA/#Model","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Model","text":"The model is four-dimensional. The dynamics are given by the following equations:\n\nbeginaligned\ndotx_1 = x_2 \ndotx_2 = -x_1 + 01 sin(x_3) \ndotx_3 = x_4  \ndotx_4 = u\nendaligned\n\nvars_idx = Dict(:states => 1:4, :controls => 5)\n\n@taylorize function TORA!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, u = x\n\n    dx[1] = x₂\n    dx[2] = -x₁ + (0.1 * sin(x₃))\n    dx[3] = x₄\n    dx[4] = u\n    dx[5] = zero(u)\n    return dx\nend;\nnothing #hide\n\nWe are given three neural-network controllers. All controllers have 3 hidden layers of 100 neurons each, 6 inputs (the state variables), and 1 output (u). The output of the neural networks N(x) needs to be normalized in order to obtain u.","category":"section"},{"location":"models/TORA/#Scenario-1","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"The controller uses ReLU activations in all layers, including the output layer. The output normalization is u = N(x) - 10. The control period is 1 time unit.\n\npath = @current_path(\"TORA\", \"TORA_ReLU_controller.polar\")\ncontroller_ReLU = read_POLAR(path)\n\ncontrol_postprocessing1 = UniformAdditivePostprocessing(-10.0)\n\nperiod1 = 1.0;\nnothing #hide","category":"section"},{"location":"models/TORA/#Scenario-2","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"One controller has ReLU activations in all hidden layers and tanh activations in the output layer. The other controller has sigmoid activations in all layers, including the output layer. The output normalization is u = 11 N(x). The control period is 0.5 time units.\n\npath = @current_path(\"TORA\", \"TORA_ReLUtanh_controller.polar\")\ncontroller_relutanh = read_POLAR(path)\npath = @current_path(\"TORA\", \"TORA_sigmoid_controller.polar\")\ncontroller_sigmoid = read_POLAR(path)\n\ncontrol_postprocessing2 = LinearMapPostprocessing(11.0)\n\nperiod2 = 0.5;\nnothing #hide","category":"section"},{"location":"models/TORA/#Specification","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Specification","text":"","category":"section"},{"location":"models/TORA/#Scenario-1-2","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"The uncertain initial condition is x_1  06 07 x_2  07 06 x_3  04 03 x_4  05 06.\n\nX₀1 = Hyperrectangle(low=[0.6, -0.7, -0.4, 0.5], high=[0.7, -0.6, -0.3, 0.6])\nU = ZeroSet(1);\nnothing #hide\n\nThe initial-value problem is:\n\nivp1 = @ivp(x' = TORA!(x), dim: 5, x(0) ∈ X₀1 × U);\nnothing #hide\n\nThe safety specification is to stay within the box x  2 2^4 for a time horizon of 20 time units. A sufficient condition for guaranteed verification is to overapproximate the result with hyperrectangles.\n\nsafe_states = cartesian_product(BallInf(zeros(4), 2.0), Universe(1))\n\npredicate1(sol, T) = overapproximate(sol, Hyperrectangle) ⊆ safe_states\n\nT1 = 20.0  # time horizon\nT1_warmup = 2 * period1  # shorter time horizon for warm-up run\nT1_reach = verification ? T1 : T1_warmup;  # shorter time horizon if not verifying\nnothing #hide","category":"section"},{"location":"models/TORA/#Scenario-2-2","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"The uncertain initial condition is x_1  -077 -075 x_2  -045 -043 x_3  051 054 x_4  -03 -028.\n\nX₀2 = Hyperrectangle(low=[-0.77, -0.45, 0.51, -0.3], high=[-0.75, -0.43, 0.54, -0.28])\nU = ZeroSet(1);\nnothing #hide\n\nThe initial-value problem is:\n\nivp2 = @ivp(x' = TORA!(x), dim: 5, x(0) ∈ X₀2 × U);\nnothing #hide\n\nThe specification is to reach the goal region x_1  -01 02 x_2  -09 -06 within 5 time units. A sufficient condition for guaranteed verification is to overapproximate the result at the end with a hyperrectangle.\n\ngoal_states = cartesian_product(Hyperrectangle(low=[-0.1, -0.9], high=[0.2, -0.6]),\n                                Universe(3))\n\npredicate_set2(R) = overapproximate(R, Hyperrectangle) ⊆ goal_states\n\npredicate2(sol, T) = all(predicate_set2(F[end]) for F in sol if T ∈ tspan(F))\n\nT2 = 5.0  # time horizon\nT2_warmup = 2 * period2;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/TORA/#Analysis","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:\n\nalgorithm_plant_1 = TMJets(abstol=3e-2, orderT=3, orderQ=1);\nalgorithm_plant_2 = TMJets(abstol=2e-2, orderT=3, orderQ=1);\nnothing #hide\n\nTo propagate sets through the neural network, we use the DeepZ algorithm. For verification, we also use an additional splitting strategy to increase the precision in scenario 1.\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe verification benchmark is given below:\n\nfunction benchmark(prob; T, splitter, algorithm_plant, predicate,\n                   silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol, T)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\n\nfunction run(; scenario1::Bool, ReLUtanh_activations)\n    if scenario1\n        println(\"# Running analysis of scenario 1 with ReLU activations\")\n        prob = ControlledPlant(ivp1, controller_ReLU, vars_idx, period1;\n                               postprocessing=control_postprocessing1)\n        splitter = verification ? BoxSplitter([4, 4, 3, 5]) : NoSplitter()\n        algorithm_plant = algorithm_plant_1\n        predicate = predicate1\n        T = T1_reach\n        T_warmup = T1_warmup\n    else\n        splitter = NoSplitter()\n        algorithm_plant = algorithm_plant_2\n        predicate = predicate2\n        T = T2\n        T_warmup = T2_warmup\n        if ReLUtanh_activations\n            println(\"# Running analysis of scenario 2 with ReLUtanh activations\")\n            prob = ControlledPlant(ivp2, controller_relutanh, vars_idx, period2;\n                                   postprocessing=control_postprocessing2)\n        else\n            println(\"# Running analysis of scenario 2 with sigmoid activations\")\n            prob = ControlledPlant(ivp2, controller_sigmoid, vars_idx, period2;\n                                   postprocessing=control_postprocessing2)\n        end\n    end\n\n    # Run the verification benchmark:\n    benchmark(prob; T=T_warmup, splitter=splitter,\n        algorithm_plant=algorithm_plant, predicate=predicate, silent=true)  # warm-up\n    res = @timed benchmark(prob; T=T, splitter=splitter,\n        algorithm_plant=algorithm_plant, predicate=predicate)  # benchmark\n    sol, result = res.value\n    @assert (result == \"verified\") \"verification failed\"\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    if scenario1\n        res = @timed simulate(prob; T=T, trajectories=10, include_vertices=true)\n    else\n        res = @timed simulate(prob; T=T, trajectories=1, include_vertices=true)\n    end\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim\nend;\nnothing #hide","category":"section"},{"location":"models/TORA/#Scenario-1-3","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"Run the verification benchmark:\n\nsol_r, sim_r = run(scenario1=true, ReLUtanh_activations=nothing);\nnothing #hide","category":"section"},{"location":"models/TORA/#Scenario-2-3","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"Run the verification benchmark for the controller with sigmoid activations:\n\nsol_sig, sim_sig = run(scenario1=false, ReLUtanh_activations=false);\nnothing #hide\n\nRun the verification benchmark for the controller with ReLU/tanh activations:\n\nsol_rt, sim_rt = run(scenario1=false, ReLUtanh_activations=true);\nnothing #hide","category":"section"},{"location":"models/TORA/#Results","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Results","text":"","category":"section"},{"location":"models/TORA/#Scenario-1-4","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 1","text":"Preprocess the results:\n\nsolz = overapproximate(sol_r, Zonotope);\nnothing #hide\n\nScript to plot the results:\n\nfunction plot_helper1(vars)\n    fig = plot()\n    plot!(fig, project(safe_states, vars); color=:lightgreen, lab=\"safe\")\n    plot!(fig, solz; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀1, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim_r; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nvars = (1, 2)\nfig = plot_helper1(vars)\nplot!(fig; xlab=\"x₁\", ylab=\"x₂\")\n# Plots.savefig(fig, \"TORA-ReLU-x1-x2.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n\nvars = (3, 4)\nfig = plot_helper1(vars)\nplot!(fig; xlab=\"x₃\", ylab=\"x₄\")\n# Plots.savefig(fig, \"TORA-ReLU-x3-x4.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/TORA/#Scenario-2-4","page":"Translational Oscillations by a Rotational Actuator (TORA)","title":"Scenario 2","text":"Script to plot the results:\n\nfunction plot_helper2(sol, sim)\n    vars = (1, 2)\n    fig = plot()\n    plot!(fig, project(goal_states, vars); color=:cyan, lab=\"goal\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀2, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    plot!(fig; xlab=\"x₁\", ylab=\"x₂\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nfig = plot_helper2(sol_sig, sim_sig)\nlens!(fig, [-0.785, -0.735], [-0.47, -0.41]; inset=(1, bbox(0.2, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[-0.77, -0.75], yticks=[-0.45, -0.43], subplot=3)\nlens!(fig, [0.09, 0.22], [-0.9, -0.8]; inset=(1, bbox(0.6, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[0.1, 0.2], yticks=[-0.9, -0.8], subplot=3)\n# Plots.savefig(fig, \"TORA-sigmoid.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n\nfig = plot_helper2(sol_rt, sim_rt)\nlens!(fig, [-0.785, -0.735], [-0.47, -0.41]; inset=(1, bbox(0.2, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[-0.77, -0.75], yticks=[-0.45, -0.43], subplot=3)\nlens!(fig, [0.0, 0.25], [-0.85, -0.7]; inset=(1, bbox(0.6, 0.4, 0.2, 0.2)),\n      lc=:black, xticks=[0, 0.2], yticks=[-0.8, -0.7], subplot=3)\n# Plots.savefig(fig, \"TORA-ReLUtanh.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/SpacecraftDocking/#Spacecraft-Docking","page":"Spacecraft Docking","title":"Spacecraft Docking","text":"The Spacecraft Docking benchmark is a model of a docking spacecraft in 2D.\n\n(Image: )\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing Plots: plot, plot!","category":"section"},{"location":"models/SpacecraftDocking/#Model","page":"Spacecraft Docking","title":"Model","text":"There are 4 state variables (s_x s_y dots_x dots_y), where (s_x s_y) is the position and (dots_x dots_y) is the velocity of the spacecraft [RCM+22].\n\nvars_idx = Dict(:states => 1:4, :controls => 5:6)\n\nconst m = 12.0\nconst n = 0.001027\nconst three_n² = 3 * n^2\nconst two_n = 2 * n\n\n@taylorize function SpacecraftDocking!(dx, x, p, t)\n    s_x, s_y, s_x′, s_y′, F_x, F_y = x\n\n    dx[1] = s_x′\n    dx[2] = s_y′\n    dx[3] = three_n² * s_x + two_n * s_y′ + F_x / m\n    dx[4] = -two_n * s_x′ + F_y / m\n    dx[5] = zero(F_x)\n    dx[6] = zero(F_y)\n    return dx\nend;\nnothing #hide\n\nWe are given a neural-network controller with 4 hidden layers of 4, 256, 256, and 4 neurons, respectively, identity activations in the first and fourth hidden layer (which represent a pre- and postprocessing via linear maps), and tanh activations everywhere else. The controller has 4 inputs (the state variables) and 2 outputs (F_x F_y).\n\npath = @current_path(\"SpacecraftDocking\", \"SpacecraftDocking_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide\n\nThe control period is 1 time unit.\n\nperiod = 1.0;\nnothing #hide","category":"section"},{"location":"models/SpacecraftDocking/#Specification","page":"Spacecraft Docking","title":"Specification","text":"We consider a smaller uncertain initial condition than originally proposed:\n\nX₀ = Hyperrectangle(low=[70, 70, -0.14, -0.14], high=[106, 106, 0.14, 0.14])\nU₀ = ZeroSet(2);\nnothing #hide\n\nThe control problem is:\n\nivp = @ivp(x' = SpacecraftDocking!(x), dim: 6, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide\n\nThe safety specification is given as follows:\n\ndots_x^2 + dots_y^2  02 + 2 n s_x^2 + s_y^2\n\nA sufficient condition for guaranteed verification is to overapproximate the result via interval arithmetic.\n\nfunction predicate_point(v::Union{AbstractVector,IntervalBox})\n    x, y, x′, y′, F_x, F_y = v\n    lhs = sqrt(x′^2 + y′^2)\n    rhs = 0.2 + two_n * sqrt(x^2 + y^2)\n    return sup(lhs) <= inf(rhs)\nend\n\nfunction predicate_set(R)\n    return predicate_point(convert(IntervalBox, box_approximation(R)))\nend\n\npredicate(sol) = all(predicate_set(R) for F in sol for R in F)\n\nT = 40.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/SpacecraftDocking/#Analysis","page":"Spacecraft Docking","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:\n\nalgorithm_plant = TMJets(abstol=5e-1, orderT=3, orderQ=1);\nnothing #hide\n\nTo propagate sets through the neural network, we use the DeepZ algorithm:\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe verification benchmark is given below:\n\nfunction benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide\n\nRun the verification benchmark and compute some simulations:\n\nbenchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=1, include_vertices=true)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"section"},{"location":"models/SpacecraftDocking/#Results","page":"Spacecraft Docking","title":"Results","text":"Script to plot the results:\n\nfunction plot_helper(vars)\n    fig = plot()\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    if vars[1] == 0\n        initial_states_projected = cartesian_product(Singleton([0.0]), project(X₀, [vars[2]]))\n        plot!(fig, initial_states_projected; c=:cornflowerblue, alpha=1, lab=\"X₀\",\n              m=:none, lw=3)\n    else\n        plot!(fig, project(X₀, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    end\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nvars = (0, 1)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"t\", ylab=\"x₁\")\n# Plots.savefig(fig, \"SpacecraftDocking.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/Airplane/#Airplane","page":"Airplane","title":"Airplane","text":"The Airplane benchmark is a simple model of a flying airplane.\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing Plots: plot, plot!, xlims!, ylims!\n\nThe following option determines whether the falsification settings should be used. The falsification settings are sufficient to show that the safety property is violated. Concretely, we start from an initial point and use a smaller time horizon.\n\nconst falsification = true;\nnothing #hide","category":"section"},{"location":"models/Airplane/#Model","page":"Airplane","title":"Model","text":"There are 12 state variables:\n\n(s_x s_y s_z v_x v_y v_z ϕ θ ψ r p q)\n\nwhere (s_x s_y s_z) is the position of the center of gravity and (v_x v_y v_z) are the components of velocity, both in (x y z) directions, (p q r) are the body rotation rates, and (ϕ θ ψ) are the Euler angles. The coordinates are visualized below.\n\n(Image: )\n\nThe equations of motion are reduced to:\n\nbeginaligned\ndotv_x =  g sin(θ) + dfracF_xm - q v_z + r v_y \ndotv_y = g cos(θ) sin(ϕ) + dfracF_ym - r v_x + p v_z \ndotv_z = g cos(θ) cos(ϕ) + dfracF_zm - p v_y + q v_x \nI_x dotp + I_xz dotr = M_x - (I_z - I_y) q r - I_xz p q \nI_y dotq = M_y - I_xz(r^2 - p^2) - (I_x - I_z) p r \nI_xz dotp + I_z dotr = M_z - (I_y - I_x) q p - I_xz r q\nendaligned\n\nwhere m denotes the mass of the airplane, I_x, I_y, I_z, and I_xz are the moments of inertia with respect to the indicated axis, and the control parameters consist of the three force components F_x, F_y, F_z and the three moment components M_x, M_y, M_z. For simplicity, we assume that the aerodynamic forces are absorbed in the F's. Beside the above six equations, we have six additional kinematic equations:\n\nbeginpmatrix\ndots_x  dots_y  dots_z\nendpmatrix\n=\nbeginpmatrix\ncos(ψ)  -sin(ψ)  0 \nsin(ψ)  cos(ψ)  0 \n0  0  1\nendpmatrix\nbeginpmatrix\ncos(θ)  0  sin(θ) \n0  1  0 \n-sin(θ)  0  cos(θ)\nendpmatrix\nbeginpmatrix\n1  0  0 \n0  cos(ϕ)  -sin(ϕ) \n0  sin(ϕ)  cos(ϕ)\nendpmatrix\nbeginpmatrix\nv_x  v_y  v_z\nendpmatrix\n\nand\n\nbeginpmatrix\ndotϕ  dotθ  dotψ\nendpmatrix\n=\nbeginpmatrix\n1  tan(θ) sin(ϕ)  tan(θ) cos(ϕ) \n0  cos(ϕ)  -sin(ϕ) \n0  sec(θ) sin(ϕ)  sec(θ) cos(ϕ)\nendpmatrix\nbeginpmatrix\np  q  r\nendpmatrix\n\nFor simplicity of the control design, the parameters have been chosen to have some nominal dimensionless values: m = 1, I_x = I_y = I_z = 1, I_xz = 0 and g = 1.\n\nvars_idx = Dict(:states => 1:12, :controls => 13:18)\n\nconst m = 1.0\nconst g = 1.0\n\nTψ(ψ) = [ cos(ψ)  -sin(ψ)  zero(ψ);\n          sin(ψ)   cos(ψ)  zero(ψ);\n         zero(ψ)  zero(ψ)   one(ψ)]\n\nTθ(θ) = [ cos(θ)  zero(θ)   sin(θ);\n         zero(θ)   one(θ)  zero(θ);\n         -sin(θ)  zero(θ)   cos(θ)]\n\nTϕ(ϕ) = [one(ϕ)  zero(ϕ)  zero(ϕ);\n         zero(ϕ)  cos(ϕ)  -sin(ϕ);\n         zero(ϕ)  sin(ϕ)   cos(ϕ)]\n\nRϕθ(ϕ, θ) = [ one(ϕ)  tan(θ) * sin(ϕ)  tan(θ) * cos(ϕ);\n             zero(ϕ)           cos(θ)          -sin(ϕ);\n             zero(ϕ)  sec(θ) * sin(ϕ)  sec(θ) * cos(ϕ)]\n\n@taylorize function Airplane!(dx, x, params, t)\n    s_x, s_y, s_z, v_x, v_y, v_z, ϕ, θ, ψ, r, p, q, Fx, Fy, Fz, Mx, My, Mz = x\n\n    T_ψ = Tψ(ψ)\n    T_θ = Tθ(θ)\n    T_ϕ = Tϕ(ϕ)\n    mat_1 = T_ψ * T_θ * T_ϕ\n    xyz = mat_1 * vcat(v_x, v_y, v_z)\n\n    mat_2 = Rϕθ(ϕ, θ)\n    ϕθψ = mat_2 * vcat(p, q, r)\n\n    dx[1] = xyz[1]\n    dx[2] = xyz[2]\n    dx[3] = xyz[3]\n    dx[4] = -g * sin(θ) + Fx / m - q * v_z + r * v_y\n    dx[5] = g * cos(θ) * sin(ϕ) + Fy / m - r * v_x + p * v_z\n    dx[6] = g * cos(θ) * cos(ϕ) + Fz / m - p * v_y + q * v_x\n    dx[7] = ϕθψ[1]\n    dx[8] = ϕθψ[2]\n    dx[9] = ϕθψ[3]\n    dx[10] = Mz  # simplified term\n    dx[11] = Mx  # simplified term\n    dx[12] = My  # simplified term\n    dx[13] = zero(Fx)\n    dx[14] = zero(Fy)\n    dx[15] = zero(Fz)\n    dx[16] = zero(Mx)\n    dx[17] = zero(My)\n    dx[18] = zero(Mz)\n    return dx\nend;\nnothing #hide\n\nWe are given a neural-network controller with 3 hidden layers of 100, 100, and 20 neurons, respectively, and ReLU activations. The controller has 12 inputs (the state variables) and 6 outputs (F_x F_y F_z M_x M_y M_z).\n\npath = @current_path(\"Airplane\", \"Airplane_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide\n\nThe control period is 0.1 time units.\n\nperiod = 0.1;\nnothing #hide","category":"section"},{"location":"models/Airplane/#Specification","page":"Airplane","title":"Specification","text":"The uncertain initial condition is:\n\nX₀ = Hyperrectangle(low=[0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                    high=[0.0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0])\nif falsification\n    # Choose a single point in the initial states (here: the top-most one):\n    X₀ = Singleton(high(X₀))\nend\nU₀ = ZeroSet(6);\nnothing #hide\n\nThe control problem is:\n\nivp = @ivp(x' = Airplane!(x), dim: 18, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide\n\nThe safety specification is that (x_2 x_7 x_8 x_9)  1 1 1 1 for 20 control periods. A sufficient condition for guaranteed violation is to overapproximate the result with hyperrectangles.\n\nsafe_states = concretize(CartesianProductArray([\n    Universe(1), Interval(-1.0, 1.0), Universe(4),\n    BallInf(zeros(3), 1.0), Universe(9)]))\n\npredicate_set(R) = isdisjoint(overapproximate(R, Hyperrectangle), safe_states)\n\nfunction predicate(sol; silent::Bool=false)\n    for F in sol, R in F\n        if predicate_set(R)\n            silent || println(\"  Violation for time range $(tspan(R)).\")\n            return true\n        end\n    end\n    return false\nend\n\nif falsification\n    k = 7  # falsification can run for a shorter time horizon\nelse\n    k = 20\nend\nT = k * period\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/Airplane/#Analysis","page":"Airplane","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:\n\nalgorithm_plant = TMJets(abstol=2e-2, orderT=3, orderQ=1);\nnothing #hide\n\nTo propagate sets through the neural network, we use the DeepZ algorithm:\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe falsification benchmark is given below:\n\nfunction benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol; silent=silent)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is violated.\")\n        result = \"falsified\"\n    else\n        silent || println(\"  The property may be satisfied.\")\n        result = \"not falsified\"\n    end\n\n    return sol, result\nend;\nnothing #hide\n\nRun the falsification benchmark and compute some simulations:\n\nbenchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"falsified\") \"falsification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=falsification ? 1 : 10,\n                      include_vertices=!falsification)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"section"},{"location":"models/Airplane/#Results","page":"Airplane","title":"Results","text":"Script to plot the results:\n\nfunction plot_helper(vars)\n    fig = plot()\n    plot!(fig, project(safe_states, vars); color=:lightgreen, lab=\"safe\")\n    plot!(fig, project(initial_state(prob), vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    lab_sim = falsification ? \"simulation\" : \"\"\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nvars = (2, 7)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"s_y\", ylab=\"ϕ\", leg=:bottomleft)\nif falsification\n    xlims!(-0.01, 1.15)\n    ylims!(0.5, 1.01)\nelse\n    xlims!(-0.55, 0.55)\n    ylims!(-1.05, 1.05)\nend\n# Plots.savefig(fig, \"Airplane.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/InvertedTwoLinkPendulum/#Inverted-Two-Link-Pendulum","page":"Inverted Two-Link Pendulum","title":"Inverted Two-Link Pendulum","text":"The Inverted Two-Link Pendulum benchmark is a classical inverted pendulum with two links. We consider two different scenarios, which we respectively refer to as the less robust and the more robust scenario.\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: Specification, NoSplitter\nusing Plots: plot, plot!, xlims!, ylims!\n\nThe following option determines whether the verification settings should be used in the less robust scenario. The verification settings are chosen to show that the safety property is satisfied, which is expensive in this case. Concretely, we split the initial states into small chunks and run many analyses. Without the verification settings, the analysis is only run for a short time horizon.\n\nconst verification = false;\nnothing #hide\n\nThe following option determines whether the falsification settings should be used in the more robust scenario. The falsification settings are sufficient to show that the safety property is violated. Concretely, we start from an initial point and use a smaller time horizon.\n\nconst falsification = true;\nnothing #hide","category":"section"},{"location":"models/InvertedTwoLinkPendulum/#Model","page":"Inverted Two-Link Pendulum","title":"Model","text":"The double-link inverted pendulum consists of equal point masses m at the end of connected mass-less links of length L. Both links are actuated with torques T_1 and T_2. We assume viscous friction with coefficient c.\n\nThe governing equations of motion can be obtained as:\n\nbeginaligned\n2 ddot θ_1 + ddot θ_2 cos(θ_2 - θ_1) - ddot θ_2^2 sin(θ_2 - θ_1) -\n    2 dfracgL sin(θ_1) + dfraccm L^2 dotθ_1 = dfrac1m L^2 T_1 \nddot θ_1 cos(θ_2 - θ_1) + ddot θ_2 + ddot θ_1^2 sin(θ_2 - θ_1) -\n    dfracgL sin(θ_2) + dfraccm L^2 dotθ_2 = dfrac1m L^2 T_2\nendaligned\n\nwhere θ_1 and θ_2 are the angles that the links make with the upward vertical axis, dotθ_1 and dotθ_2 are the angular velocities, and g is the gravitational acceleration. The state vector is (θ_1 θ_2 dotθ_1 dotθ_2). See the picture below for a visualization.\n\n(Image: )\n\nThe dynamics are given as first-order differential equations below.\n\nvars_idx = Dict(:states => 1:4, :controls => 5:6)\n\nconst m = 0.5\nconst L = 0.5\nconst c = 0.0\nconst g = 1.0\nconst gL = g / L\nconst mL = 1 / (m * L^2)\n\n@taylorize function InvertedTwoLinkPendulum!(dx, x, p, t)\n    θ₁, θ₂, θ₁′, θ₂′, T₁, T₂ = x\n\n    Δ12 = θ₁ - θ₂\n    cos12 = cos(Δ12)\n    x3sin12 = θ₁′^2 * sin(Δ12)\n    x4sin12 = θ₂′^2 * sin(Δ12) / 2\n    gLsin1 = gL * sin(θ₁)\n    gLsin2 = gL * sin(θ₂)\n    T1_frac = (T₁ - c * θ₁′) * (0.5 * mL)\n    T2_frac = (T₂ - c * θ₂′) * mL\n    bignum = x3sin12 - cos12 * (gLsin1 - x4sin12 + T1_frac) + gLsin2 + T2_frac\n    denom = cos12^2 / 2 - 1\n\n    dx[1] = θ₁′\n    dx[2] = θ₂′\n    dx[3] = cos12 * bignum / (2 * denom) - x4sin12 + gLsin1 + T1_frac\n    dx[4] = -bignum / denom\n    dx[5] = zero(T₁)\n    dx[6] = zero(T₂)\n    return dx\nend;\nnothing #hide\n\nWe are given two neural-network controllers with 2 hidden layers of 25 neurons each and ReLU activations. Both controllers have 4 inputs (the state variables) and 2 output (T₁ and T₂).\n\npath = @current_path(\"InvertedTwoLinkPendulum\",\n                     \"InvertedTwoLinkPendulum_controller_less_robust.polar\")\ncontroller_lr = read_POLAR(path)\n\npath = @current_path(\"InvertedTwoLinkPendulum\",\n                     \"InvertedTwoLinkPendulum_controller_more_robust.polar\")\ncontroller_mr = read_POLAR(path);\nnothing #hide\n\nThe controllers have different control periods: 0.05 (less robust) resp. 0.02 (more robust) time units.\n\nperiod_lr = 0.05\nperiod_mr = 0.02;\nnothing #hide","category":"section"},{"location":"models/InvertedTwoLinkPendulum/#Specification","page":"Inverted Two-Link Pendulum","title":"Specification","text":"The uncertain initial condition is (θ_1 θ_2 dotθ_1 dotθ_2)  1 13^4.\n\nThe safety specification is that, for all times t for 20 control periods, we have (θ_1 θ_2 dotθ_1 dotθ_2)  -1 17^4 (less robust scenario) respectively (θ_1 θ_2 dotθ_1 dotθ_2)  -05 15^4 (more robust scenario). A sufficient condition for guaranteed violation is to overapproximate the result with hyperrectangles.\n\nThe following script creates a different problem instance for the less robust and the more robust scenario, respectively.\n\nfunction InvertedTwoLinkPendulum_spec(less_robust_scenario::Bool)\n    controller = less_robust_scenario ? controller_lr : controller_mr\n\n    X₀ = BallInf(fill(1.15, 4), 0.15)\n    if falsification && !less_robust_scenario\n        # Choose a single point in the initial states (here: the top-most one):\n        X₀ = Singleton(high(X₀))\n    end\n    U₀ = ZeroSet(2)\n\n    period = less_robust_scenario ? period_lr : period_mr\n\n    # The control problem is:\n    ivp = @ivp(x' = InvertedTwoLinkPendulum!(x), dim: 6, x(0) ∈ X₀ × U₀)\n    prob = ControlledPlant(ivp, controller, vars_idx, period)\n\n    # Safety specification:\n    if less_robust_scenario\n        box = BallInf(fill(0.15, 4), 1.85)\n    else\n        box = BallInf(fill(0.0, 4), 1.5)\n    end\n    safe_states = cartesian_product(box, Universe(2))\n\n    predicate_set_safe(R) = overapproximate(R, Hyperrectangle) ⊆ safe_states\n    predicate_set_unsafe(R) = isdisjoint(overapproximate(R, Hyperrectangle), safe_states)\n\n    function predicate_safe(sol; silent::Bool=false)\n        for F in sol, R in F\n            if !predicate_set_safe(R)\n                silent || println(\"  Potential violation for time range $(tspan(R)).\")\n                return false\n            end\n        end\n        return true\n    end\n\n    function predicate_unsafe(sol)\n        for F in sol, R in F\n            if predicate_set_unsafe(R)\n                return true\n            end\n        end\n        return false\n    end\n\n    if less_robust_scenario\n        predicate = predicate_safe\n    else\n        predicate = predicate_unsafe\n    end\n\n    if !verification && less_robust_scenario\n        # Run for a shorter time horizon if verification is deactivated:\n        k = 2\n    elseif falsification && !less_robust_scenario\n        # Falsification can run for a shorter time horizon:\n        k = 18\n    else\n        k = 20\n    end\n    T = k * period  # time horizon\n\n    spec = Specification(T, predicate, safe_states)\n\n    return prob, spec\nend;\nnothing #hide","category":"section"},{"location":"models/InvertedTwoLinkPendulum/#Analysis","page":"Inverted Two-Link Pendulum","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm. We also use an additional splitting strategy to increase the precision. These algorithms are defined later for each scenario. To propagate sets through the neural network, we use the DeepZ algorithm:\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe verification/falsification benchmark (depending on the scenario) is given below:\n\nfunction benchmark(prob, spec; T, algorithm_plant, splitter, less_robust_scenario, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    if less_robust_scenario\n        res = @timed spec.predicate(sol; silent=silent)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is verified.\")\n            result = \"verified\"\n        else\n            silent || println(\"  The property may be violated.\")\n            result = \"not verified\"\n        end\n    else\n        res = @timed spec.predicate(sol)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is violated.\")\n            result = \"falsified\"\n        else\n            silent || println(\"  The property may be satisfied.\")\n            result = \"not falsified\"\n        end\n    end\n\n    return sol, result\nend\n\nfunction run(; less_robust_scenario::Bool)\n    if less_robust_scenario\n        println(\"# Running analysis with less robust scenario\")\n        algorithm_plant = TMJets(abstol=1e-9, orderT=5, orderQ=1)\n        splitter = !verification ? BoxSplitter([[1.15], [1.15], Float64[], [1.2]]) :\n            BoxSplitter([[1.15], [1.15], [1.12, 1.25], [1.05, 1.11, 1.165, 1.21, 1.257]])\n        T_warmup = 2 * period_lr  # shorter time horizon for warm-up run\n    else\n        println(\"# Running analysis with more robust scenario\")\n        algorithm_plant = TMJets(abstol=1e-2, orderT=3, orderQ=1)\n        splitter = NoSplitter()\n        T_warmup = 2 * period_mr  # shorter time horizon for warm-up run\n    end\n    prob, spec = InvertedTwoLinkPendulum_spec(less_robust_scenario)\n\n    # Run the verification/falsification benchmark:\n    benchmark(prob, spec; T=T_warmup, algorithm_plant=algorithm_plant, splitter=splitter,\n              less_robust_scenario=less_robust_scenario, silent=true)  # warm-up\n    res = @timed benchmark(prob, spec; T=spec.T, algorithm_plant=algorithm_plant,  # benchmark\n                           splitter=splitter, less_robust_scenario=less_robust_scenario)\n    sol, result = res.value\n    if verification && less_robust_scenario\n        @assert (result == \"verified\") \"verification failed\"\n    elseif !less_robust_scenario\n        @assert (result == \"falsified\") \"falsification failed\"\n    end\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    simulations = less_robust_scenario || !falsification\n    trajectories = simulations ? 10 : 1\n    res = @timed simulate(prob; T=spec.T, trajectories=trajectories,\n                          include_vertices=simulations)\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim, prob, spec\nend;\nnothing #hide\n\nRun the analysis script for the less robust scenario:\n\nsol_lr, sim_lr, prob_lr, spec_lr = run(less_robust_scenario=true);\nnothing #hide\n\nRun the analysis script for the more robust scenario:\n\nsol_mr, sim_mr, prob_mr, spec_mr = run(less_robust_scenario=false);\nnothing #hide","category":"section"},{"location":"models/InvertedTwoLinkPendulum/#Results","page":"Inverted Two-Link Pendulum","title":"Results","text":"Script to plot the results:\n\nfunction plot_helper(vars, sol, sim, prob, spec; lab_sim=\"\")\n    safe_states = spec.ext\n    fig = plot()\n    plot!(fig, project(safe_states, vars); color=:lightgreen, lab=\"safe\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(initial_state(prob), vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nvars = (1, 2)\nfig = plot_helper(vars, sol_lr, sim_lr, prob_lr, spec_lr)\nplot!(fig; xlab=\"θ₁\", ylab=\"θ₂\")\n# Command to save the plot to a file:\n# Plots.savefig(fig, \"InvertedTwoLinkPendulum-less-robust-x1-x2.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n\nvars = (3, 4)\nfig = plot_helper(vars, sol_lr, sim_lr, prob_lr, spec_lr)\nplot!(fig; xlab=\"θ₁'\", ylab=\"θ₂'\")\n# Command to save the plot to a file:\n# Plots.savefig(fig, \"InvertedTwoLinkPendulum-less-robust-x3-x4.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n\nvars = (3, 4)\nlab_sim = falsification ? \"simulation\" : \"\"\nfig = plot_helper(vars, sol_mr, sim_mr, prob_mr, spec_mr; lab_sim=lab_sim)\nplot!(fig; xlab=\"θ₁'\", ylab=\"θ₂'\")\n# Command to save the plot to a file:\n# Plots.savefig(fig, \"InvertedTwoLinkPendulum-more-robust.png\")\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/VerticalCAS/#Vertical-Collision-Avoidance-System-(VerticalCAS)","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Vertical Collision Avoidance System (VerticalCAS)","text":"The VerticalCAS benchmark considers a collision avoidance system (CAS), required for commercial aircraft, which gives vertical climbrate advisories to pilots [JK19, ABKL20].\n\nusing ClosedLoopReachability, LinearAlgebra\nimport Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: FeedforwardNetwork\nusing Plots: plot, plot!","category":"section"},{"location":"models/VerticalCAS/#Model","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Model","text":"This model is a closed-loop variant of the aircraft collision avoidance system ACAS X. The considered scenario involves two aircraft, the ownship and the intruder, where the ownship is equipped with a collision avoidance system referred to as VerticalCAS. VerticalCAS issues vertical climbrate advisories to the ownship pilot every second to avoid a near mid-air collision (NMAC), which is the region where the aircraft are separated by less than 100 ft vertically and 500 ft horizontally. The ownship is assumed to have a constant horizontal speed, and the intruder is assumed to follow a constant horizontal trajectory toward the ownship. The figure below illustrates the scenario, where the ownship is shown in black and the intruder is shown in red.\n\n(Image: )\n\nThe current geometry of the system is described by the intruder altitude relative to the ownship h (in ft), the ownship vertical climbrate doth_0 (in ft/min), and the time τ (in seconds) until the ownship and intruder are no longer horizontally separated. We can assume that the intruder is static and the horizontal separation τ decreases by 1 each second.\n\nIn addition to the parameters describing the geometry of the encounter, the dynamics also depend on the advisory textitadv issued to the ownship at the previous time step. The following data structure stores all this information:\n\nstruct State{T}\n    state::T  # state for (h, hdot0) variables\n    τ::Float64\n    adv::Symbol\nend;\nnothing #hide\n\nThere are 9 advisories, each of which instructs the pilot to accelerate until the vertical climbrate of the ownship complies with the advisory:\n\nCOC: Clear of Conflict\nDNC: Do Not Climb\nDND: Do Not Descend\nDES1500: Descend at least 1500 ft/min\nCL1500: Climb at least 1500 ft/min\nSDES1500: Strengthen Descent to at least 1500 ft/min\nSCL1500: Strengthen Climb to at least 1500 ft/min\nSDES2500: Strengthen Descent to at least 2500 ft/min\nSCL2500: Strengthen Climb to at least 2500 ft/min\n\nconst index2advisory = [:COC, :DNC, :DND, :DES1500, :CL1500,\n                        :SDES1500, :SCL1500, :SDES2500, :SCL2500];\nnothing #hide\n\nWe create a dictionary that maps each advisory to a set corresponding to the respective constraint on the climbrate:\n\nconst advisory2set = Dict{Symbol,LazySet}()\nadvisory2set[:COC] = EmptySet(1)\nadvisory2set[:DNC] = HalfSpace([1.0], 0.0)\nadvisory2set[:DND] = HalfSpace([-1.0], 0.0)\nadvisory2set[:DES1500] = HalfSpace([1.0], -1500.0)\nadvisory2set[:CL1500] = HalfSpace([-1.0], -1500.0)\nadvisory2set[:SDES1500] = HalfSpace([1.0], -1500.0)\nadvisory2set[:SCL1500] = HalfSpace([-1.0], -1500.0)\nadvisory2set[:SDES2500] = HalfSpace([1.0], -2500.0)\nadvisory2set[:SCL2500] = HalfSpace([-1.0], -2500.0);\nnothing #hide\n\nVerticalCAS is implemented as nine neural networks N_i, one for each (previous) advisory. All neural networks have the same structure: five hidden layers of 20 neurons each and ReLU activations, three inputs (h doth_0 τ), and nine outputs representing the score of each possible advisory.\n\nWe create a dictionary that maps each advisory to the respective controller:\n\nconst advisory2controller = Dict{Symbol,FeedforwardNetwork}()\n\npath_prefix = @current_path(\"VerticalCAS\", \"\")\nfor i in 1:9\n    path = joinpath(path_prefix, \"VerticalCAS_controller_$(i).polar\")\n    adv = index2advisory[i]\n    advisory2controller[adv] = read_POLAR(path)\nend;\nnothing #hide\n\nBefore passing the input to the neural networks, it has to be normalized by shifting and scaling in each dimension:\n\nconst normalization_additive = -[0.0, 0, 20]\nconst normalization_multiplicative = 1.0 ./ [16000.0, 5000, 40]\nconst normalization_multiplicative_X = diagm(normalization_multiplicative)\n\nfunction normalize(x::AbstractVector)\n    y = x .+ normalization_additive\n    z = normalization_multiplicative .* y\n    return z\nend\n\nfunction normalize(X::LazySet)\n    Y = translate(X, normalization_additive)\n    Z = linear_map(normalization_multiplicative_X, Y)\n    return Z\nend;\nnothing #hide\n\nGiven a current state (h doth_0 τ textitadv), the new advisory textitadv is computed as the argmax of the output score of N_textitadv on (h doth_0 τ):\n\nfunction next_adv(X::LazySet, τ, adv; algorithm_controller=DeepZ())\n    Y = cartesian_product(X, Singleton([τ]))\n    Y = normalize(Y)\n    out = forward(Y, advisory2controller[adv], algorithm_controller)\n    imax = argmax(high(out))\n    return index2advisory[imax]\nend\n\nfunction next_adv(X::Singleton, τ, adv; algorithm_controller=nothing)\n    v = vcat(element(X), τ)\n    v = normalize(v)\n    u = forward(v, advisory2controller[adv])\n    imax = argmax(u)\n    return index2advisory[imax]\nend;\nnothing #hide\n\nGiven the new advisory, the pilot can choose acceleration ddoth_0 as follows.\n\nIf the new advisory is COC (1), then any acceleration from the set left-dfracg8 0 dfracg8right can be chosen, where g represents the gravitational constant 322 ft/s^2.\nFor all remaining advisories, if the previous advisory coincides with the new one and the current climb rate complies with the new advisory (e.g., doth_0 is non-positive for DNC and doth_0  1500 for CL1500), the acceleration ddoth_0 is 0.\nOtherwise, the pilot can choose acceleration ddoth_0 from the sets given below (for convenience, we also list the options for COC again).\nCOC: left-dfracg8 0 dfracg8right\nDNC: left-dfracg3 -dfrac7g24 -dfracg4right\nDND: leftdfracg4 dfrac7g24 dfracg3right\nDES1500: left-dfracg3 -dfrac7g24 -dfracg4right\nCL1500: leftdfracg4 dfrac7g24 dfracg3right\nSDES1500: left-dfracg3right\nSCL1500: leftdfracg3right\nSDES2500: left-dfracg3right\nSCL2500: leftdfracg3right\n\nBelow we only consider the central options.\n\nconst g = 32.2\nconst acc_central = Dict(:COC => 0.0, :DNC => -7g / 24, :DND => 7g / 24,\n                         :DES1500 => -7g / 24, :CL1500 => 7g / 24, :SDES1500 => -g / 3,\n                         :SCL1500 => g / 3, :SDES2500 => -g / 3, :SCL2500 => g / 3);\nnothing #hide\n\nThe following function receives X = h doth_0 τ textitadv as well as the previous advisory textitadv, and returns the new acceleration ddoth_0:\n\nfunction next_acc(X::State, adv; acc=acc_central)\n    # Project on hdot and transform units from ft/s to ft/min:\n    hdot = 60 * _interval(X.state, 2)\n\n    # New advisory:\n    adv′ = X.adv\n\n    # Check whether the current state complies with the advisory:\n    comply = hdot ⊆ advisory2set[adv′]\n\n    return (comply && adv == adv′) ? 0.0 : acc[adv′]\nend;\nnothing #hide\n\nGiven the current system state (h doth_0 τ textitadv), the new advisory textitadv, and the acceleration ddoth_0, the new state of the system (h(k+1) doth_0(k+1) τ(k+1)textitadv(k+1)) is computed as follows:\n\nbeginaligned\nh(k+1) = h(k) - doth_0(k) Δτ - 05 ddoth_0(k) Δτ^2 \ndoth_0(k+1) = doth_0(k) + ddoth_0(k) Δτ \nτ(k+1) = τ(k) - Δτ \ntextitadv(k+1) = textitadv\nendaligned\n\nwhere Δτ = 1.\n\nconst Δτ = 1.0\nconst A = [1 -Δτ; 0 1]  # dynamics matrix (h, \\dot{h}_0)\n\nfunction VerticalCAS!(out::Vector{<:State}, kmax::Int; acc, algorithm_controller)\n    # Unpack the initial state:\n    X0 = first(out)\n    S = X0.state\n    τ = X0.τ\n    adv = X0.adv\n\n    for k in 1:kmax\n        # Get the next advisory and acceleration:\n        adv′ = next_adv(S, τ, adv; algorithm_controller=algorithm_controller)\n        X = State(S, τ, adv′)\n        hddot = next_acc(X, adv; acc=acc)\n\n        # Compute and store the next state:\n        b = [-hddot * Δτ^2 / 2, hddot * Δτ]\n        S′ = affine_map(A, S, b)\n        τ′ = τ - Δτ\n        X′ = State(S′, τ′, adv′)\n        push!(out, X′)\n\n        # Update the current state:\n        S = S′\n        τ = τ′\n        adv = adv′\n    end\n    return out\nend;\nnothing #hide","category":"section"},{"location":"models/VerticalCAS/#Specification","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Specification","text":"The uncertain initial condition is h in -133 -129, doth_0 in -195 -225 -255 -285, τ = 25, and textitadv = textCOC:\n\nconst h_0 = Interval(-133.0, -129.0)\nconst hdot0_0 = [-19.5, -22.5, -25.5, -28.5]\nconst τ_0 = 25.0\nconst adv_0 = :COC;\nnothing #hide\n\nThe safety specification is that the ownship avoids entering the NMAC zone within k in 1  10 steps, i.e., h(k)  100 or h(k)  -100, for all possible choices of acceleration by the pilot.\n\nunsafe_states = HalfSpace([0.0, 1.0], 100.0) ∩ HalfSpace([0.0, -1.0], 100.0)\n\npredicate_set(R) = isdisjoint(R, unsafe_states)\n\npredicate(sol) = all(predicate_set(R) for R in sol)\n\nkmax = 10\nkmax_warmup = 2;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/VerticalCAS/#Analysis","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Analysis","text":"Helper function to obtain initial states from hdot0(0):\n\nfunction get_initial_states(hdot0_0i)\n    S0 = convert(Zonotope, cartesian_product(h_0, Singleton([hdot0_0i])))\n    return State(S0, τ_0, adv_0)\nend;\nnothing #hide\n\nHelper function to run a simulation:\n\nfunction simulate_VerticalCAS(X0::State; kmax)\n    out = [X0]\n    sizehint!(out, kmax + 1)\n    VerticalCAS!(out, kmax; acc=acc_central, algorithm_controller=DeepZ())\n    return out\nend;\nnothing #hide\n\nHelper function to obtain an interval of dimension i:\n\n_interval(X::LazySet, i) = Interval(extrema(X, i)...);\nnothing #hide\n\nHelper function to project onto the h variable:\n\nfunction _project(X::Vector{State{T}}) where {T<:Singleton}\n    return [Singleton([Xi.τ, Xi.state.element[1]]) for Xi in X]\nend\n\nfunction _project(X::Vector{State{T}}) where {T<:LazySet}\n    return [Singleton([Xi.τ]) × _interval(Xi.state, 1) for Xi in X]\nend;\nnothing #hide\n\nThe falsification benchmark is given below:\n\nfunction benchmark(X0; kmax, silent::Bool=false)\n    res = @timed begin\n        seq = simulate_VerticalCAS(X0; kmax=kmax)\n        _project(seq)\n    end\n    sol = res.value\n    silent || print_timed(res)\n\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property is violated.\")\n        result = \"falsified\"\n    end\n\n    return sol, result\nend;\nnothing #hide\n\nSimulation result for all choices of velocity:\n\nprintln(\"Running flowpipe construction with central advisories:\")\nsol_all = []\nfor hdot0_0i in hdot0_0\n    println(\"Running instance hdot0(0) = $hdot0_0i:\")\n    X0 = get_initial_states(hdot0_0i)\n    benchmark(X0; kmax=kmax_warmup, silent=true)  # warm-up\n    res = @timed benchmark(X0; kmax=kmax)  # benchmark\n    sol, result = res.value\n    push!(sol_all, sol)\n    if hdot0_0i ∈ [-19.5, -22.5]\n        @assert (result == \"verified\") \"verification failed\"\n    elseif hdot0_0i ∈ [-25.5, -28.5]\n        @assert (result == \"falsified\") \"falsification failed\"\n    end\n    println(\"Total analysis time:\")\n    print_timed(res)\nend","category":"section"},{"location":"models/VerticalCAS/#Results","page":"Vertical Collision Avoidance System (VerticalCAS)","title":"Results","text":"Preprocess the results (extend from time points to time intervals):\n\nfunction extend_x(X::Singleton; Δ=Δτ)\n    return LineSegment(element(X) .- [Δ, 0], element(X))\nend\n\nfunction extend_x(cp::CartesianProduct; Δ=Δτ)\n    x = first(element(first(cp)))\n    X = Interval(x - Δ, x)\n    return CartesianProduct(X, LazySets.second(cp))\nend\n\nfunction extend_x(sol_all::Vector)\n    return [vcat([extend_x(X) for X in F[1:(end - 1)]], extend_x(F[end]; Δ=0.1)) for F in sol_all]\nend\n\nsol_all = extend_x(sol_all);\nnothing #hide\n\nScript to plot the results:\n\nfunction plot_helper()\n    fig = plot(ylab=\"h (vertical distance)\", xlab=\"τ (time to reach horizontally)\",\n               xflip=true, leg=:topright, xticks=14:25)\n    unsafe_states_projected = cartesian_product(Universe(1),\n                                                project(unsafe_states, [2]))\n    plot!(fig, unsafe_states_projected; alpha=0.2, c=:red, lab=\"unsafe\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nfig = plot_helper()\nfor (i, c) in [(1, :brown), (2, :green), (3, :orange), (4, :cyan)]\n    lab = \"h_0′ = $(hdot0_0[i])\"\n    for o in sol_all[i]\n        plot!(fig, o; lw=2, alpha=1, seriestype=:shape, c=c, lab=lab)\n        lab = \"\"\n    end\nend\nplot!(fig, xlims=(14.9, 25), ylims=(-310, -70))\n# Plots.savefig(\"VerticalCAS.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"lib/problems/#Problem-types","page":"Problem types","title":"Problem types","text":"","category":"section"},{"location":"lib/problems/#Closed-loop-system","page":"Problem types","title":"Closed-loop system","text":"","category":"section"},{"location":"lib/problems/#ClosedLoopReachability.ControlledPlant","page":"Problem types","title":"ClosedLoopReachability.ControlledPlant","text":"ControlledPlant{ST, CT, XT, DT, PT, CPRT, CPST} <: AbstractControlProblem\n\nStruct representing a closed-loop controlled system.\n\nFields\n\nivp            – initial-value problem\ncontroller     – controller\nvars           – dictionary storing state variables, input variables and                     control variables\nperiod         – control period\npostprocessing – postprocessing of the controller output\npreprocessing  – preprocessing of the controller input\n\nParameters\n\nST:  type of system\nCT:  type of controller\nXT:  type of initial condition\nDT:  type of variables\nPT:  type of period\nCPRT: type of control preprocessing\nCPST: type of control postprocessing\n\nNotes\n\nWhile typically the controller is a neural network, this struct does not prescribe the type.\n\n\n\n\n\n","category":"type"},{"location":"models/Unicycle/#Unicycle","page":"Unicycle","title":"Unicycle","text":"The Unicycle benchmark models a unicycle vehicle [AKM17].\n\n(Image: )\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: UniformAdditivePostprocessing\nusing Plots: plot, plot!, lens!, bbox","category":"section"},{"location":"models/Unicycle/#Model","page":"Unicycle","title":"Model","text":"There are 4 state variables (x_1 x_2 x_3 x_4), where (x_1 x_2) describe the x and y coordinates in the plane, x_3 is the velocity, and x_4 is the steering angle. The dynamics are given as follows:\n\nbeginaligned\ndotx_1 = x_4 cos(x_3) \ndotx_2 = x_4 sin(x_3) \ndotx_3 = u_2 \ndotx_4 = u_1 + w\nendaligned\n\nwhere w is a bounded error in the range 10^4 10^4, which we model as a nondeterministically assigned constant for simplicity.\n\nvars_idx = Dict(:states => 1:4, :disturbances => [5], :controls => 6:7)\n\n@taylorize function Unicycle!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, w, u₁, u₂ = x\n\n    dx[1] = x₄ * cos(x₃)\n    dx[2] = x₄ * sin(x₃)\n    dx[3] = u₂\n    dx[4] = u₁ + w\n    dx[5] = zero(x[5])\n    dx[6] = zero(x[6])\n    dx[7] = zero(x[7])\n    return dx\nend;\nnothing #hide\n\nWe are given a neural-network controller with 1 hidden layer of 500 neurons and ReLU activations in all layers, including the output layer. The controller has 4 inputs (the state variables) and 2 outputs (u_1 and u_2). The output of the neural network N(x) needs to be normalized in order to obtain u, namely (u_1 u_2) = N(x) - (20 20).\n\npath = @current_path(\"Unicycle\", \"Unicycle_controller.polar\")\ncontroller = read_POLAR(path)\n\ncontrol_postprocessing = UniformAdditivePostprocessing(-20.0);\nnothing #hide\n\nThe control period is 0.2 time units.\n\nperiod = 0.2;\nnothing #hide","category":"section"},{"location":"models/Unicycle/#Specification","page":"Unicycle","title":"Specification","text":"The uncertain initial condition is:\n\nx_1  95955 x_2  45445 x_3  21211 x_4  15151\n\nX₀ = Hyperrectangle(low=[9.5, -4.5, 2.1, 1.5, -1e-4],\n                    high=[9.55, -4.45, 2.11, 1.51, 1e-4])\nU₀ = ZeroSet(2);\nnothing #hide\n\nThe control problem is:\n\nivp = @ivp(x' = Unicycle!(x), dim: 7, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period;\n                       postprocessing=control_postprocessing);\nnothing #hide\n\nThe specification is to reach the goal region\n\nx_1  0606 x_2  0202 x_3  006006 x_4  0303\n\nuntil a time horizon of 10 time units. A sufficient condition for guaranteed verification is to overapproximate the result at the end with a hyperrectangle.\n\ngoal_set = cartesian_product(Hyperrectangle(zeros(4), [0.6, 0.2, 0.06, 0.3]),\n                             Universe(3))\n\npredicate_set(R) = overapproximate(R, Hyperrectangle, tend(R)) ⊆ goal_set\n\npredicate(sol) = all(predicate_set(F[end]) for F in sol if T ∈ tspan(F))\n\nT = 10.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/Unicycle/#Analysis","page":"Unicycle","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:\n\nalgorithm_plant = TMJets(abstol=1e-1, orderT=3, orderQ=1);\nnothing #hide\n\nTo propagate sets through the neural network, we use the DeepZ algorithm. We also use an additional splitting strategy to increase the precision.\n\nalgorithm_controller = DeepZ()\nsplitter = BoxSplitter([3, 1, 7, 1]);\nnothing #hide\n\nThe verification benchmark is given below:\n\nfunction benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide\n\nRun the verification benchmark and compute some simulations:\n\nbenchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=5, include_vertices=false)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"section"},{"location":"models/Unicycle/#Results","page":"Unicycle","title":"Results","text":"Preprocess the results:\n\nsolz = overapproximate(sol, Zonotope)\nTint = try convert(Int, T) catch; T end;\nnothing #hide\n\nScript to plot the results:\n\nfunction plot_helper(vars; show_simulation::Bool=true)\n    fig = plot()\n    plot!(fig, project(goal_set, vars); color=:cyan, alpha=0.5, lab=\"goal\")\n    plot!(fig, solz; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀, vars); color=:cornflowerblue, alpha=1, lab=\"X₀\")\n    lab = \"reach set at t = $Tint\"\n    for F in sol\n        if T ∈ tspan(F)\n            plot!(fig, overapproximate(F[end], Zonotope, tend(F));\n                  vars=vars, color=:orange, lab=lab)\n            lab = \"\"\n        end\n    end\n    if show_simulation\n        plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    end\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nvars = (1, 2)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"x₁\", ylab=\"x₂\", leg=:bottomleft)\nlens!(fig, [9.49, 9.56], [-4.51, -4.44]; inset=(1, bbox(0.65, 0.05, 0.25, 0.25)),\n      lc=:black, xticks=[9.5, 9.55], yticks=[-4.5, -4.45], subplot=2)\nlens!(fig, [0.3, 0.7], [-0.25, 0.25]; inset=(1, bbox(0.1, 0.3, 0.25, 0.25)),\n      lc=:black, xticks=[0.4, 0.6], yticks=[-0.2, 0.2], subplot=3)\n# Plots.savefig(fig, \"Unicycle-x1-x2.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n\nvars = (3, 4)\nfig = plot_helper(vars; show_simulation=false)\nplot!(fig; xlab=\"x₃\", ylab=\"x₄\", leg=:bottom)\nlens!(fig, [2.09, 2.12], [1.495, 1.515]; inset=(1, bbox(0.72, 0.54, 0.25, 0.25)),\n      lc=:black, xticks=[2.1, 2.11], yticks=[1.5, 1.51], subplot=2)\nlens!(fig, [-0.1, 0.03], [-0.4, -0.15]; inset=(1, bbox(0.1, 0.1, 0.25, 0.25)),\n      lc=:black, xticks=[-0.08, 0], yticks=[-0.3, -0.2], subplot=3)\n# Plots.savefig(fig, \"Unicycle-x3-x4.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/InvertedPendulum/#Inverted-Pendulum","page":"Inverted Pendulum","title":"Inverted Pendulum","text":"The Inverted Pendulum benchmark is a classical model of motion. We consider two scenarios, which we refer to as the verification and the falsification scenario.\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.Arrays: SingleEntryVector\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: Specification, NoSplitter\nusing Plots: plot, plot!, xlims!, ylims!, lens!, bbox, savefig","category":"section"},{"location":"models/InvertedPendulum/#Model","page":"Inverted Pendulum","title":"Model","text":"A ball of mass m is attached to a massless beam of length L. The beam is actuated with a torque T. We assume viscous friction with coefficient c.\n\nThe governing equation of motion can be obtained as follows:\n\nddotθ = dfracgL sin(θ) + dfrac1m L^2 (T - c dotθ)\n\nwhere θ is the angle that the link makes with the upward vertical axis, dotθ is the angular velocity, and g is the gravitational acceleration. The state vector is (θ dotθ). The model constants are chosen as m = L = 05, c = 0, and g = 1.\n\n(Image: )\n\nvars_idx = Dict(:states => 1:2, :controls => 3)\n\nconst m = 0.5\nconst L = 0.5\nconst c = 0.0\nconst g = 1.0\nconst gL = g / L\nconst mL = 1 / (m * L^2)\n\n@taylorize function InvertedPendulum!(dx, x, p, t)\n    θ, θ′, T = x\n\n    dx[1] = θ′\n    dx[2] = gL * sin(θ) + mL * (T - c * θ′)\n    dx[3] = zero(T)\n    return dx\nend;\nnothing #hide\n\nWe are given a neural-network controller with 2 hidden layers of 25 neurons each and ReLU activations. The controller has 2 inputs (the state variables) and 1 output (T).\n\npath = @current_path(\"InvertedPendulum\", \"InvertedPendulum_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide\n\nThe control period is 0.05 time units.\n\nperiod = 0.05;\nnothing #hide","category":"section"},{"location":"models/InvertedPendulum/#Specification","page":"Inverted Pendulum","title":"Specification","text":"The following script creates a different problem instance for the two scenarios, respectively.\n\nfunction InvertedPendulum_spec(verification::Bool)\n    # The uncertain initial condition is ``\\dot{θ} \\in [0, 0.2]``, and ``θ``\n    # depends on the scenario.\n    if verification\n        # ``θ \\in [1, 1.175]``.\n        X₀ = Hyperrectangle(low=[1.0, 0], high=[1.175, 0.2])\n    else\n        # ``θ \\in [1, 1.2]``. We choose a single point (here: the top-most one):\n        X₀ = Singleton(high(BallInf([1.1, 0.1], 0.1)))\n    end\n    U₀ = ZeroSet(1);\n\n    # The control problem is:\n\n    ivp = @ivp(x' = InvertedPendulum!(x), dim: 3, x(0) ∈ X₀ × U₀)\n    prob = ControlledPlant(ivp, controller, vars_idx, period);\n\n    # The safety specification is that ``θ ∈ [0, 1]`` for ``t ∈ [0.5, 1]``\n    # (i.e., the control periods ``10 ≤ k ≤ 20``). A sufficient condition for a\n    # guaranteed verdict is to overapproximate the result with hyperrectangles.\n\n    if verification\n        unsafe_states = UnionSet(HalfSpace(SingleEntryVector(1, 3, -1.0), -1.0),\n                                 HalfSpace(SingleEntryVector(1, 3, 1.0), 0.0))\n    else\n        unsafe_states = HalfSpace(SingleEntryVector(1, 3, -1.0), -1.0)\n    end\n\n    function predicate_set_safe(R)\n        t = tspan(R)\n        return sup(t) <= 0.5 ||\n            isdisjoint(overapproximate(R, Hyperrectangle), unsafe_states)\n    end\n\n    function predicate_safe(sol; silent::Bool=false)\n        for F in sol\n            t = tspan(F)\n            if sup(t) <= 0.5\n                continue\n            end\n            for R in F\n                if !predicate_set_safe(R)\n                    silent || println(\"  Potential violation for time range $(tspan(R)).\")\n                    return false\n                end\n            end\n        end\n        return true\n    end\n\n    function predicate_set_unsafe(R)\n        t = tspan(R)\n        return inf(t) >= 0.5 && sup(t) <= 1.0 &&\n            overapproximate(R, Hyperrectangle) ⊆ unsafe_states\n    end\n\n    function predicate_unsafe(sol; silent::Bool=false)\n        for F in sol\n            t = tspan(F)\n            if sup(t) < 0.5\n                continue\n            end\n            for R in F\n                if predicate_set_unsafe(R)\n                    silent || println(\"  Violation for time range $(tspan(R)).\")\n                    return true\n                end\n            end\n        end\n        return false\n    end\n\n    if verification\n        predicate = predicate_safe\n    else\n        predicate = predicate_unsafe\n    end\n\n    if verification\n        T = 1.0\n    else\n        T = 11 * period  # falsification can run for a shorter time horizon\n    end\n\n    spec = Specification(T, predicate, unsafe_states)\n\n    return prob, spec\nend\n\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/InvertedPendulum/#Analysis","page":"Inverted Pendulum","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm. We also use an additional splitting strategy to increase the precision. These algorithms are defined later for each scenario. To propagate sets through the neural network, we use the DeepZ algorithm:\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe falsification benchmark is given below:\n\nfunction benchmark(prob, spec; T, algorithm_plant, splitter, verification, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant, splitter=splitter)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    if verification\n        res = @timed spec.predicate(sol; silent=silent)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is verified.\")\n            result = \"verified\"\n        else\n            silent || println(\"  The property may be violated.\")\n            result = \"not verified\"\n        end\n    else\n        res = @timed spec.predicate(sol; silent=silent)\n        silent || print_timed(res)\n        if res.value\n            silent || println(\"  The property is violated.\")\n            result = \"falsified\"\n        else\n            silent || println(\"  The property may be satisfied.\")\n            result = \"not falsified\"\n        end\n    end\n\n    return sol, result\nend\n\nfunction run(; verification::Bool)\n    if verification\n        println(\"# Running analysis with verification scenario\")\n        algorithm_plant = TMJets(abstol=1e-9, orderT=5, orderQ=1)\n        splitter = BoxSplitter([[1.1, 1.16], [0.09, 0.145, 0.18]])\n    else\n        println(\"# Running analysis with falsification scenario\")\n        algorithm_plant = TMJets(abstol=1e-7, orderT=4, orderQ=1)\n        splitter = NoSplitter()\n    end\n    prob, spec = InvertedPendulum_spec(verification)\n\n    # Run the verification/falsification benchmark:\n    benchmark(prob, spec; T=T_warmup, algorithm_plant=algorithm_plant, splitter=splitter,\n              verification=verification, silent=true)  # warm-up\n    res = @timed benchmark(prob, spec; T=spec.T, algorithm_plant=algorithm_plant,  # benchmark\n                           splitter=splitter, verification=verification)\n    sol, result = res.value\n    if verification\n        @assert (result == \"verified\") \"verification failed\"\n    else\n        @assert (result == \"falsified\") \"falsification failed\"\n    end\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    trajectories = verification ? 10 : 1\n    res = @timed simulate(prob; T=spec.T, trajectories=trajectories,\n                          include_vertices=verification)\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim, prob, spec\nend;\nnothing #hide\n\nRun the analysis script for the verification scenario:\n\nsol_v, sim_v, prob_v, spec_v = run(verification=true);\nnothing #hide\n\nRun the analysis script for the falsification scenario:\n\nsol_f, sim_f, prob_f, spec_f = run(verification=false);\nnothing #hide","category":"section"},{"location":"models/InvertedPendulum/#Results","page":"Inverted Pendulum","title":"Results","text":"Script to plot the results:\n\nfunction plot_helper(sol, sim, prob, spec, verification)\n    vars = (0, 1)\n    fig = plot(leg=:topright)\n    lab = \"unsafe\"\n    unsafe_states = spec.ext isa UnionSet ? spec.ext : [spec.ext]\n    for B in unsafe_states\n        unsafe_states_projected = cartesian_product(Interval(0.5, 1.0), project(B, [vars[2]]))\n        plot!(fig, unsafe_states_projected; color=:red, alpha=:0.2, lab=lab)\n        lab = \"\"\n    end\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    initial_states_projected =\n        cartesian_product(Singleton([0.0]), project(initial_state(prob), [vars[2]]))\n    plot!(fig, initial_states_projected; c=:cornflowerblue, alpha=1, m=:none, lw=7, lab=\"X₀\")\n    lab_sim = verification ? \"\" : \"simulation\"\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=lab_sim)\n    xlims!(0, spec.T)\n    plot!(fig; xlab=\"t\", ylab=\"θ\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nfig = plot_helper(sol_v, sim_v, prob_v, spec_v, true)\nylims!(fig, 0.5, 1.2)\nlens!(fig, [0.49, 0.52], [0.99, 1.01]; inset=(1, bbox(0.1, 0.6, 0.3, 0.3)),\n      lc=:black, xticks=[0.5], yticks=[1.0], subplot=3)\n# Plots.savefig(fig, \"InvertedPendulum_verification.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n\nfig = plot_helper(sol_f, sim_f, prob_f, spec_f, false)\nylims!(fig, 0.95, 1.22)\n# Plots.savefig(fig, \"InvertedPendulum_falsification.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/AttitudeControl/#Attitude-Control","page":"Attitude Control","title":"Attitude Control","text":"The Attitude Control benchmark models a rigid-body system [PPR04].\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing Plots: plot, plot!","category":"section"},{"location":"models/AttitudeControl/#Model","page":"Attitude Control","title":"Model","text":"There are 6 state variables: (ω_1 ω_2 ω_3 ψ_1 ψ_2 ψ_3). The system dynamics are given as follows:\n\nbeginaligned\ndotω_1 = 025 (u_0 + ω_2 ω_3) \ndotω_2 = 05 (u_1 - 3 ω_1 ω_3) \ndotω_3 = u_2 + 2 ω_1 ω_2) \ndotψ_1 = 05 (ω₂ (ξ - ψ₃) + ω₃ (ξ + ψ₂) + ω₁ (ξ + 1)) \ndotψ_2 = 05 (ω₁ (ξ + ψ₃) + ω₃ (ξ - ψ₁) + ω₂ (ξ + 1)) \ndotψ_3 = 05 (ω₁ (ξ - ψ₂) + ω₂ (ξ + ψ₁) + ω₃ (ξ + 1))\nendaligned\n\nwhere ω = (ω_1 ω_2 ω_3) is the angular velocity in a body-fixed frame, ψ = (ψ_1 ψ_2 ψ_3) are the Rodrigues parameters, and ξ = ψ₁^2 + ψ₂^2 + ψ₃^2.\n\nvars_idx = Dict(:states => 1:6, :controls => 7:9)\n\n@taylorize function AttitudeControl!(dx, x, p, t)\n    ω₁, ω₂, ω₃, ψ₁, ψ₂, ψ₃, u₀, u₁, u₂ = x\n\n    ξ = ψ₁^2 + ψ₂^2 + ψ₃^2\n\n    dx[1] = 0.25 * (u₀ + ω₂ * ω₃)\n    dx[2] = 0.5 * (u₁ - 3 * ω₁ * ω₃)\n    dx[3] = u₂ + 2 * ω₁ * ω₂\n    dx[4] = 0.5 * (  ω₂ * (ξ - ψ₃)\n                   + ω₃ * (ξ + ψ₂)\n                   + ω₁ * (ξ + 1))\n    dx[5] = 0.5 * (  ω₁ * (ξ + ψ₃)\n                   + ω₃ * (ξ - ψ₁)\n                   + ω₂ * (ξ + 1))\n    dx[6] = 0.5 * (  ω₁ * (ξ - ψ₂)\n                   + ω₂ * (ξ + ψ₁)\n                   + ω₃ * (ξ + 1))\n    dx[7] = zero(u₀)\n    dx[8] = zero(u₁)\n    dx[9] = zero(u₂)\n    return dx\nend;\nnothing #hide\n\nWe are given a neural-network controller with 3 hidden layers of 64 neurons each and sigmoid activations. The controller has 6 inputs (the state variables) and 3 outputs (u_0 u_1 u_2).\n\npath = @current_path(\"AttitudeControl\", \"AttitudeControl_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide\n\nThe control period is 0.1 time units.\n\nperiod = 0.1;\nnothing #hide","category":"section"},{"location":"models/AttitudeControl/#Specification","page":"Attitude Control","title":"Specification","text":"The uncertain initial condition is:\n\nX₀ = Hyperrectangle(low=[-0.45, -0.55, 0.65, -0.75, 0.85, -0.65],\n                    high=[-0.44, -0.54, 0.66, -0.74, 0.86, -0.64])\nU₀ = ZeroSet(3);\nnothing #hide\n\nThe control problem is:\n\nivp = @ivp(x' = AttitudeControl!(x), dim: 9, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide\n\nThe safety specification is that a set of unsafe states should not be reached within 3 time units. A sufficient condition for guaranteed verification is to overapproximate the result with hyperrectangles.\n\nunsafe_states = cartesian_product(\n    Hyperrectangle(low=[-0.2, -0.5, 0,   -0.7, 0.7, -0.4],\n                   high=[0,   -0.4, 0.2, -0.6, 0.8, -0.2]),\n    Universe(3))\n\npredicate(sol) = isdisjoint(overapproximate(sol, Hyperrectangle), unsafe_states);\n\nT = 3.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/AttitudeControl/#Analysis","page":"Attitude Control","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:\n\nalgorithm_plant = TMJets(abstol=1e-4, orderT=5, orderQ=1);\nnothing #hide\n\nTo propagate sets through the neural network, we use the DeepZ algorithm:\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe verification benchmark is given below:\n\nfunction benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide\n\nRun the verification benchmark and compute some simulations:\n\nbenchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=10, include_vertices=false)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"section"},{"location":"models/AttitudeControl/#Results","page":"Attitude Control","title":"Results","text":"Script to plot the results:\n\nfunction plot_helper(vars)\n    fig = plot()\n    plot!(fig, project(unsafe_states, vars); color=:red, alpha=:0.2,\n          lab=\"unsafe\", leg=:topleft)\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot!(fig, project(X₀, vars); c=:cornflowerblue, alpha=1, lab=\"X₀\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nvars = (1, 2)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"ω₁\", ylab=\"ω₂\")\n# Plots.savefig(fig, \"AttitudeControl.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/Quadrotor/#Quadrotor","page":"Quadrotor","title":"Quadrotor","text":"The Quadrotor benchmark is a model of a flying drone with four rotors.\n\n(Image: )\n\nusing ClosedLoopReachability\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.Arrays: SingleEntryVector\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing Plots: plot, plot!","category":"section"},{"location":"models/Quadrotor/#Model","page":"Quadrotor","title":"Model","text":"There are 12 state variables (x_1  x_12), where (x_1 x_2) is the inertial position (north and east), x_3 is the altitude, (x_4 x_5 x_6) is the velocity (longitudinal, lateral, vertical), (x_7 x_8 x_9) is the (roll, pitch, yaw) angle, and (x_10 x_11 x_12) is the (roll, pitch, yaw) rate. The control inputs (u_1 u_2 u_3) represent the torque. For more details we refer to Beard [Bea08].\n\nvars_idx = Dict(:states => 1:12, :controls => 13:15)\n\nconst g = 9.81\nconst m = 1.4\nconst Jx = 0.054\nconst Jy = 0.054\nconst Jz = 0.104\nconst Cyzx = (Jy - Jz) / Jx\nconst Czxy = (Jz - Jx) / Jy\nconst Cxyz = (Jx - Jy) / Jz\nconst τψ = 0.0\nconst Tz = τψ / Jz;\nnothing #hide\n\nThe differential equations can be simplified using knowledge about the model constants:\n\n@taylorize function Quadrotor!(dx, x, p, t)\n    x₁, x₂, x₃, x₄, x₅, x₆, x₇, x₈, x₉, x₁₀, x₁₁, x₁₂, u₁, u₂, u₃ = x\n\n    F₁ = g + u₁ / m\n    Tx = u₂ / Jx\n    Ty = u₃ / Jy\n    sx7 = sin(x₇)\n    cx7 = cos(x₇)\n    sx8 = sin(x₈)\n    cx8 = cos(x₈)\n    sx9 = sin(x₉)\n    cx9 = cos(x₉)\n    sx7sx9 = sx7 * sx9\n    sx7cx9 = sx7 * cx9\n    cx7sx9 = cx7 * sx9\n    cx7cx9 = cx7 * cx9\n    sx7cx8 = sx7 * cx8\n    cx7cx8 = cx7 * cx8\n    sx7_cx8 = sx7 / cx8\n    x4cx8 = cx8 * x₄\n    xdot9 = sx7_cx8 * x₁₁\n\n    dx[1] = (cx9 * x4cx8 + (sx7cx9 * sx8 - cx7sx9) * x₅) + (cx7cx9 * sx8 + sx7sx9) * x₆\n    dx[2] = (sx9 * x4cx8 + (sx7sx9 * sx8 + cx7cx9) * x₅) + (cx7sx9 * sx8 - sx7cx9) * x₆\n    dx[3] = (sx8 * x₄ - sx7cx8 * x₅) - cx7cx8 * x₆\n    dx[4] = -x₁₁ * x₆ - g * sx8\n    dx[5] = x₁₀ * x₆ + g * sx7cx8\n    dx[6] = (x₁₁ * x₄ - x₁₀ * x₅) + (g * cx7cx8 - F₁)\n    dx[7] = x₁₀ + sx8 * xdot9\n    dx[8] = cx7 * x₁₁\n    dx[9] = xdot9\n    dx[10] = Tx\n    dx[11] = Ty\n    dx[12] = zero(x[12])\n    dx[13] = zero(u₁)\n    dx[14] = zero(u₂)\n    dx[15] = zero(u₃)\n    return dx\nend;\nnothing #hide\n\nWe are given a neural-network controller with 3 hidden layers of 64 neurons each and sigmoid activations. The controller has 12 inputs (the state variables) and 3 outputs (u_1 u_2 u_3).\n\npath = @current_path(\"Quadrotor\", \"Quadrotor_controller.polar\")\ncontroller = read_POLAR(path);\nnothing #hide\n\nThe control period is 0.1 time units.\n\nperiod = 0.1;\nnothing #hide","category":"section"},{"location":"models/Quadrotor/#Specification","page":"Quadrotor","title":"Specification","text":"We consider a smaller uncertain initial condition than originally proposed; specifically, the set is a hyperrectangle with 1% of the original radius:\n\nr = [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0, 0, 0, 0, 0, 0]  # original radius\nX₀ = Hyperrectangle(zeros(12), 0.01 * r)\nU₀ = ZeroSet(3);\nnothing #hide\n\nThe control problem is:\n\nivp = @ivp(x' = Quadrotor!(x), dim: 15, x(0) ∈ X₀ × U₀)\nprob = ControlledPlant(ivp, controller, vars_idx, period);\nnothing #hide\n\nThe specification is to stabilize the attitude x_3 to the goal region 094 106 until a time horizon of 50 time units. A sufficient condition for guaranteed verification is to overapproximate the result at the end with a hyperrectangle.\n\ngoal_states = HPolyhedron([HalfSpace(SingleEntryVector(3, 15, -1.0), -0.94),\n                           HalfSpace(SingleEntryVector(3, 15, 1.0), 1.06)])\n\npredicate_set(R) = overapproximate(R, Hyperrectangle) ⊆ goal_states\n\npredicate(sol) = all(predicate_set(F[end]) for F in sol if T ∈ tspan(F))\n\nT = 5.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/Quadrotor/#Analysis","page":"Quadrotor","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:\n\nalgorithm_plant = TMJets(abstol=1e-1, orderT=3, orderQ=1);\nnothing #hide\n\nTo propagate sets through the neural network, we use the DeepZ algorithm:\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe verification benchmark is given below:\n\nfunction benchmark(; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide\n\nRun the verification benchmark and compute some simulations:\n\nbenchmark(T=T_warmup, silent=true)  # warm-up\nres = @timed benchmark(T=T)  # benchmark\nsol, result = res.value\n@assert (result == \"verified\") \"verification failed\"\nprintln(\"Total analysis time:\")\nprint_timed(res)\n\nprintln(\"Simulation:\")\nres = @timed simulate(prob; T=T, trajectories=1, include_vertices=false)\nsim = res.value\nprint_timed(res);\nnothing #hide","category":"section"},{"location":"models/Quadrotor/#Results","page":"Quadrotor","title":"Results","text":"Script to plot the results:\n\nfunction plot_helper(vars)\n    goal_states_projected = cartesian_product(Interval(0, T),\n                                              project(goal_states, [vars[2]]))\n    fig = plot()\n    plot!(fig, goal_states_projected; color=:cyan, lab=\"goal\")\n    plot!(fig, sol; vars=vars, color=:yellow, lw=0, alpha=1, lab=\"\")\n    plot_simulation!(fig, sim; vars=vars, color=:black, lab=\"\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nvars = (0, 3)\nfig = plot_helper(vars)\nplot!(fig; xlab=\"t\", ylab=\"x₃\")\n# Plots.savefig(fig, \"Quadrotor.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))","category":"section"},{"location":"models/ACC/#Adaptive-Cruise-Control-(ACC)","page":"Adaptive Cruise Control (ACC)","title":"Adaptive Cruise Control (ACC)","text":"The Adaptive Cruise Control (ACC) benchmark models a car that drives at a set velocity and maintains a safe distance from a lead car by adjusting the longitudinal acceleration [TCL+19].\n\n(Image: )\n\nusing ClosedLoopReachability, LinearAlgebra\nimport OrdinaryDiffEq, Plots, DisplayAs\nusing ReachabilityBase.CurrentPath: @current_path\nusing ReachabilityBase.Timing: print_timed\nusing ClosedLoopReachability: FunctionPreprocessing\nusing Plots: plot, plot!","category":"section"},{"location":"models/ACC/#Model","page":"Adaptive Cruise Control (ACC)","title":"Model","text":"The cars' dynamics are modeled as follows:\n\nbeginaligned\ndotx_lead = v_lead \ndotv_lead = γ_lead \ndotγ_lead = -2 γ_lead + 2 a_lead - u v_lead^2 \ndotx_ego = v_ego \ndotv_ego = γ_ego \ndotγ_ego = -2 γ_ego + 2 a_ego - u v_ego^2\nendaligned\n\nwhere u = 00001 is the friction parameter, and for each car i  ego lead we have that x_i is the position, v_i is the velocity, γ_i is the acceleration, and a_i is the control input for the acceleration.\n\nvars_idx = Dict(:states => 1:6, :controls => 7)\n\nconst u = 0.0001\nconst a_lead = -2.0\n\n@taylorize function ACC!(dx, x, p, t)\n    v_lead = x[2]  # lead car velocity\n    γ_lead = x[3]  # lead car acceleration\n    v_ego = x[5]  # ego car velocity\n    γ_ego = x[6]  # ego car acceleration\n    a_ego = x[7]  # ego car acceleration control input\n\n    # Lead-car dynamics:\n    dx[1] = v_lead\n    dx[2] = γ_lead\n    dx[3] = 2 * (a_lead - γ_lead) - u * v_lead^2\n\n    # Ego-car dynamics:\n    dx[4] = v_ego\n    dx[5] = γ_ego\n    dx[6] = 2 * (a_ego - γ_ego) - u * v_ego^2\n\n    dx[7] = zero(a_ego)\n    return dx\nend;\nnothing #hide\n\nWe are given two neural-network controllers with 5 hidden layers of 20 neurons each. One controller uses ReLU activations and the other controller uses tanh activations. Both controllers have 5 inputs (v_set T_gap v_ego D_rel v_rel) and one output (a_ego), where v_set = 30 is the ego car's set velocity, T_gap = 14, D_rel = x_lead - x_ego is the distance between the cars, and v_rel = v_lead - v_ego is the distance between the velocities.\n\npath = @current_path(\"ACC\", \"ACC_controller_relu.polar\")\ncontroller_relu = read_POLAR(path)\n\npath = @current_path(\"ACC\", \"ACC_controller_tanh.polar\")\ncontroller_tanh = read_POLAR(path);\nnothing #hide\n\nThe controller input is (v_set T_gap v_ego D_rel v_rel), for which we define a transformation matrix M.\n\nv_set = 30.0\nT_gap = 1.4\nM = zeros(3, 6)\nM[1, 5] = 1.0\nM[2, 1] = 1.0\nM[2, 4] = -1.0\nM[3, 2] = 1.0\nM[3, 5] = -1.0\nfunction preprocess(X::LazySet)  # version for set computations\n    Y1 = Singleton([v_set, T_gap])\n    Y2 = linear_map(M, X)\n    return cartesian_product(Y1, Y2)\nend\nfunction preprocess(X::AbstractVector)  # version for simulations\n    Y1 = [v_set, T_gap]\n    Y2 = M * X\n    return vcat(Y1, Y2)\nend\ncontrol_preprocessing = FunctionPreprocessing(preprocess);\nnothing #hide\n\nThe control period is 0.1 time units.\n\nperiod = 0.1;\nnothing #hide","category":"section"},{"location":"models/ACC/#Specification","page":"Adaptive Cruise Control (ACC)","title":"Specification","text":"The uncertain initial condition is:\n\nbeginaligned\nx_lead  90 110 v_lead  32 322 γ_lead = 0 \nx_ego  10 11 v_ego  30 302 γ_ego = 0\nendaligned\n\nX₀ = Hyperrectangle(low=[90, 32, 0, 10, 30, 0],\n                    high=[110, 32.2, 0, 11, 30.2, 0])\nU₀ = ZeroSet(1);\nnothing #hide\n\nThe control problem (parametric in the controller) is:\n\nivp = @ivp(x' = ACC!(x), dim: 7, x(0) ∈ X₀ × U₀)\nproblem(controller) = ControlledPlant(ivp, controller, vars_idx, period;\n                                      preprocessing=control_preprocessing);\nnothing #hide\n\nWe consider a scenario where both cars are driving safely and the lead car suddenly slows down with a_lead = -2. We want to verify that there is no collision in the following 5 time units, i.e., the ego car must maintain a safe distance D_safe from the lead car. Formally, the safety specification is D_rel  D_safe, where D_safe = D_default + T_gap  v_ego and D_default = 10. After substitution, the specification reduces to x_lead - x_ego - T_gap  v_ego  D_default. A sufficient condition for guaranteed verification is to overapproximate the result with hyperrectangles.\n\nD_default = 10.0\nd_rel = [1.0, 0, 0, -1, 0, 0, 0]\nd_safe = [0, 0, 0, 0, T_gap, 0, 0]\nd_prop = d_rel - d_safe\nsafe_states = HalfSpace(-d_prop, -D_default)\n\npredicate(sol) = overapproximate(sol, Hyperrectangle) ⊆ safe_states\n\nT = 5.0\nT_warmup = 2 * period;  # shorter time horizon for warm-up run\nnothing #hide","category":"section"},{"location":"models/ACC/#Analysis","page":"Adaptive Cruise Control (ACC)","title":"Analysis","text":"To enclose the continuous dynamics, we use a Taylor-model-based algorithm:\n\nalgorithm_plant = TMJets(abstol=1e-3, orderT=5, orderQ=1);\nnothing #hide\n\nTo propagate sets through the neural network, we use the DeepZ algorithm:\n\nalgorithm_controller = DeepZ();\nnothing #hide\n\nThe verification benchmark is given below:\n\nfunction benchmark(prob; T=T, silent::Bool=false)\n    # Solve the controlled system:\n    silent || println(\"Flowpipe construction:\")\n    res = @timed solve(prob; T=T, algorithm_controller=algorithm_controller,\n                       algorithm_plant=algorithm_plant)\n    sol = res.value\n    silent || print_timed(res)\n\n    # Check the property:\n    silent || println(\"Property checking:\")\n    res = @timed predicate(sol)\n    silent || print_timed(res)\n    if res.value\n        silent || println(\"  The property is satisfied.\")\n        result = \"verified\"\n    else\n        silent || println(\"  The property may be violated.\")\n        result = \"not verified\"\n    end\n\n    return sol, result\nend;\nnothing #hide\n\nFor each controller we execute the same analysis script, which runs the verification benchmark and computes simulations:\n\nfunction run(; use_relu_controller::Bool)\n    if use_relu_controller\n        println(\"# Running analysis with ReLU controller\")\n        prob = problem(controller_relu)\n    else\n        println(\"# Running analysis with tanh controller\")\n        prob = problem(controller_tanh)\n    end\n\n    # Run the verification benchmark:\n    benchmark(prob; T=T_warmup, silent=true)  # warm-up\n    res = @timed benchmark(prob; T=T)  # benchmark\n    sol, result = res.value\n    @assert (result == \"verified\") \"verification failed\"\n    println(\"Total analysis time:\")\n    print_timed(res)\n\n    # Compute some simulations:\n    println(\"Simulation:\")\n    res = @timed simulate(prob; T=T, trajectories=10, include_vertices=true)\n    sim = res.value\n    print_timed(res)\n\n    return sol, sim\nend;\nnothing #hide\n\nRun the analysis script for the ReLU controller:\n\nsol_relu, sim_relu = run(use_relu_controller=true);\nnothing #hide\n\nRun the analysis script for the tanh controller:\n\nsol_tanh, sim_tanh = run(use_relu_controller=false);\nnothing #hide","category":"section"},{"location":"models/ACC/#Results","page":"Adaptive Cruise Control (ACC)","title":"Results","text":"Script to plot the results:\n\nfunction plot_helper(sol, sim)\n    fig = plot(leg=(0.4, 0.3))\n    for F in sol, R in F\n        # Subdivide the reach sets in time to obtain more precise plots:\n        R = overapproximate(R, Zonotope; ntdiv=5)\n        R_rel = linear_map(Matrix(d_rel'), R)\n        plot!(fig, R_rel; vars=(0, 1), c=:red, lw=0, alpha=0.4)\n    end\n\n    solz = overapproximate(flowpipe(sol), Zonotope)\n    fp_safe = affine_map(Matrix(d_safe'), solz, [D_default])\n    plot!(fig, fp_safe; vars=(0, 1), c=:blue, lw=0, alpha=0.4)\n\n    output_map_rel = x -> dot(d_rel, x)\n    plot_simulation!(fig, sim; output_map=output_map_rel, color=:red, lab=\"Drel\")\n\n    output_map_safe = x -> dot(d_safe, x) + D_default\n    plot_simulation!(fig, sim; output_map=output_map_safe, color=:blue, lab=\"Dsafe\")\n\n    plot!(fig; xlab=\"time\")\n    return fig\nend;\nnothing #hide\n\nPlot the results:\n\nfig = plot_helper(sol_relu, sim_relu)\n# Plots.savefig(fig, \"ACC-ReLU.png\")  # command to save the plot to a file\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n\nfig = plot_helper(sol_tanh, sim_tanh)\nfig = DisplayAs.Text(DisplayAs.PNG(fig))\n# savefig(fig, \"ACC-tanh.png\")  # command to save the plot to a file","category":"section"},{"location":"lib/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"lib/solvers/#Flowpipe-computation","page":"Solvers","title":"Flowpipe computation","text":"","category":"section"},{"location":"lib/solvers/#Trajectory-simulation","page":"Solvers","title":"Trajectory simulation","text":"","category":"section"},{"location":"lib/solvers/#CommonSolve.solve","page":"Solvers","title":"CommonSolve.solve","text":"solve(prob::AbstractControlProblem, args...; kwargs...)\n\nSolve the control problem defined by prob.\n\nInput\n\nprob – controlled problem\n\nAdditional options are passed as arguments or keyword arguments; see the notes below for details. See the online documentation for examples.\n\nOutput\n\nThe solution of a reachability problem controlled by a periodic controller. The control signals are stored in the ext field with each flowpipe.\n\nNotes\n\nMandatory arguments\n\nUse the tspan keyword argument to specify the time span (start time and time\n\nhorizon); it can be a tuple, an interval, or a vector with two components. Alternatively, use the T keyword argument to specify only the time horizon, in which case the start time is assumed to be zero.\n\nUse the algorithm_plant keyword argument to specify the algorithm for the\n\nplant.\n\nUse the algorithm_controller keyword argument to specify the algorithm for\n\nthe controller.\n\nOptional arguments\n\nUse the splitter and input_splitter keyword arguments to specify a\n\nsplitter.\n\nDefault: NoSplitter()\n\nUse the reconstruction_method keyword arguments to specify a reconstruction\n\nmethod for the interface between plant and controller.\n\nDefault: TaylorModelReconstructor()\n\n\n\n\n\n","category":"function"},{"location":"lib/solvers/#ClosedLoopReachability.simulate","page":"Solvers","title":"ClosedLoopReachability.simulate","text":"simulate(cp::AbstractControlProblem, args...; kwargs...)\n\nSimulate a controlled system for a family of random trajectories.\n\nInput\n\ncp           – controlled problem\ntrajectories – (optional, default: 10) number of simulated trajectories\n\nOutput\n\nAn object of type EnsembleSimulationSolution.\n\nNotes\n\nThis function uses the ensemble simulations feature from OrdinaryDiffEq.jl.\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"M. E. Akintunde, E. Botoeva, P. Kouvaros and A. Lomuscio. Formal Verification of Neural Agents in Non-deterministic Environments. In: Autonomous Agents and Multiagent Systems (AAMAS), edited by A. E. Seghrouchni, G. Sukthankar, B. An and N. Yorke-Smith (IFAAMAS, 2020); pp. 25–33.\n\n\n\nM. Althoff, M. Koschi and S. Manzinger. CommonRoad: Composable benchmarks for motion planning on roads. In: Intelligent Vehicles (IV) (IEEE, 2017); pp. 719–726.\n\n\n\nR. W. Beard. Quadrotor dynamics and control. Technical Report 1325 (Brigham Young University, 2008).\n\n\n\nM. Jankovic, D. Fontaine and P. V. Kokotovic. TORA example: cascade- and passivity-based control designs. Transactions on Control Systems Technology 4, 292–297 (1996).\n\n\n\nK. D. Julian and M. J. Kochenderfer. A Reachability Method for Verifying Dynamical Systems with Deep Neural                   Network Controllers. CoRR abs/1903.00520 (2019), arXiv:1903.00520.\n\n\n\nS. Prajna, P. A. Parrilo and A. Rantzer. Nonlinear control synthesis by convex optimization. Transactions on Automatic Control 49, 310–314 (2004).\n\n\n\nU. J. Ravaioli, J. Cunningham, J. McCarroll, V. Gangal, K. Dunlap and K. L. Hobbs. Safe reinforcement learning benchmark environments for aerospace control systems. In: Aerospace Conference (AERO) (IEEE, 2022); pp. 1–20.\n\n\n\nH.-D. Tran, F. Cai, D. M. Lopez, P. Musau, T. T. Johnson and X. D. Koutsoukos. Safety Verification of Cyber-Physical Systems with Reinforcement Learning                   Control. Transactions on Embedded Computing Systems 18, 105:1–105:22 (2019).\n\n\n\n","category":"section"}]
}
